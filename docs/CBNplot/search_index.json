[["index.html", "CBNplot Chapter 1 CBNplot: Bayesian network plot for enrichment analysis results 1.1 The preprocessing and DEG identification of GSE133624", " CBNplot Noriaki Sato Chapter 1 CBNplot: Bayesian network plot for enrichment analysis results The R package to plot Bayesian network inferred from expression data based on the enrichment analysis results including clusterProfiler or ReactomePA results (Wu et al. 2021; Yu and He 2016). It makes use of libraries including clusterProfiler, ReactomePA, bnlearn, graphite and depmap (Killian and Gatto 2021; Scutari 2010; Sales et al. 2012). The description of functions and several use cases are depicted in this book using GSE133624, which contains RNA-Seq data of bladder cancer and adjacent normal bladder tissues (Chen et al. 2019). 1.1 The preprocessing and DEG identification of GSE133624 In this book, the data from GSE133624 was used for the demonstrative purpose, and the parameters can be changed. First, DESeq2 is used to identify DEGs (Love, Huber, and Anders 2014). library(DESeq2) ## Load dataset and make metadata counts = read.table(&quot;GSE133624_reads-count-all-sample.txt&quot;, header=1, row.names=1) meta = sapply(colnames(counts), function (x) substring(x,1,1)) meta = data.frame(meta) colnames(meta) = c(&quot;Condition&quot;) dds &lt;- DESeqDataSetFromMatrix(countData = counts, colData = meta, design= ~ Condition) ## Prefiltering filt &lt;- rowSums(counts(dds) &lt; 10) &gt; dim(meta)[1]*0.9 dds &lt;- dds[!filt,] ## Perform DESeq2() dds = DESeq(dds) res = results(dds, pAdjustMethod = &quot;bonferroni&quot;) ## apply variance stabilizing transformation v = vst(dds, blind=FALSE) vsted = assay(v) ## Plot PCA of VST values DESeq2::plotPCA(v, intgroup=&quot;Condition&quot;)+ theme_bw() ## Define the input genes, and use clusterProfiler::bitr to convert the ID. sig = subset(res, padj&lt;0.05) cand.entrez = clusterProfiler::bitr(rownames(sig), fromType=&quot;ENSEMBL&quot;, toType=&quot;ENTREZID&quot;, OrgDb=org.Hs.eg.db)$ENTREZID ## Perform enrichment analysis (ORA) pway = ReactomePA::enrichPathway(gene = cand.entrez) pwayGO = clusterProfiler::enrichGO(cand.entrez, ont = &quot;MF&quot;, OrgDb = org.Hs.eg.db) ## Convert to SYMBOL pway = setReadable(pway, OrgDb=org.Hs.eg.db) pwayGO = setReadable(pwayGO, OrgDb=org.Hs.eg.db) ## Store the similarity pway = enrichplot::pairwise_termsim(pway) ## Define including samples incSample = rownames(subset(meta, Condition==&quot;T&quot;)) Additionally, for the gene set enrichment analysis, log2 fold changes are obtained. allEntrez = clusterProfiler::bitr(rownames(res), fromType=&quot;ENSEMBL&quot;, toType=&quot;ENTREZID&quot;, OrgDb=org.Hs.eg.db) res$ENSEMBL &lt;- rownames(res) lfc &lt;- merge(data.frame(res), allEntrez, by=&quot;ENSEMBL&quot;) lfc &lt;- lfc[order(lfc$log2FoldChange, decreasing=TRUE),] geneList &lt;- lfc$log2FoldChange names(geneList) &lt;- lfc$ENTREZID pwayGSE &lt;- ReactomePA::gsePathway(geneList) The mean gene count in the pathway, which is used in the inference. sigpway &lt;- subset(pway@result, p.adjust&lt;0.05) paste(mean(sigpway$Count), sd(sigpway$Count)) FALSE [1] &quot;29.6976744186047 22.0886288379294&quot; References "],["bootstrap-based-inference.html", "Chapter 2 bootstrap-based inference 2.1 bootstrap-based inference 2.2 Multiscale boostrap-based inference", " Chapter 2 bootstrap-based inference For bayesian network inference, two methods can be used. 2.1 bootstrap-based inference Original boot.strength() function from bnlearn follows parameterization of Imoto et al. (2002). Specify strType=\"normal\" which is default. Estimate the gene network \\(T\\) times from randomly sampled \\(X^*_{n} = (x^*_{1},...,x^*_{n})^T\\). Edge intensity is defined as \\((t1+t2)/T\\), and if \\(t1&gt;t2\\), edge confidence is defined as the confidence of direction of gene \\(i\\) to gene \\(j\\) is \\(t1/(t1+t2)\\), where the \\(t1\\) corresponds to the number of edges of gene \\(i\\) to \\(j\\) and \\(t2\\) the number of edges of gene \\(j\\) to \\(i\\). 2.2 Multiscale boostrap-based inference Additionally, the multiscale boostrap-based inference is implemented (Kamimura et al. 2003). Specify strType=\"ms\" for the multiscale version. The drawback is that it consumes more time. \\(n&#39;/n\\) was defined as the same parameter as the original paper. \\[n&#39;/n = (0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4)\\] For the arrays with altered numbers of multiple \\(\\tau=\\sqrt{n/n&#39;}\\), the bootstrap-based inference are performed. \\(MS_{ij}\\) is defined as \\(1-\\Phi(d_{ij}-c_{ij})\\), using the geometric quantities \\(d_{ij}\\) and \\(c_{ij}\\). Fitting \\(BP_{ij}(\\tau) = 1-\\Phi(d_{ij}/\\tau+c_{ij}\\tau)\\), we can determine the \\(MS_{ij}\\). The fitting was performed by msfit() available in pvclust. The confidence of direction was obtained by the same method as obtaining \\(MS_{ij}\\). The resulting edges were filtered by the threshold determined by the function inclusion.threshold from bnlearn. For both approaches, the superposed network possibly does not hold the cyclic assumption (Imoto et al. 2002). References "],["bngeneplot.html", "Chapter 3 bngeneplot 3.1 barplot 3.2 The vanilla plot 3.3 The plot with the reference 3.4 The plot with the DepMap information 3.5 Plotting edge strengths 3.6 Plotting genes in multiple pathways", " Chapter 3 bngeneplot # Show top-30 pathways sorted by p-value in descending order. pway@result$Description[1:30] FALSE [1] &quot;Cell Cycle Checkpoints&quot; FALSE [2] &quot;Amplification of signal from the kinetochores&quot; FALSE [3] &quot;Amplification of signal from unattached kinetochores via a MAD2 inhibitory signal&quot; FALSE [4] &quot;Mitotic Prometaphase&quot; FALSE [5] &quot;Resolution of Sister Chromatid Cohesion&quot; FALSE [6] &quot;Mitotic Spindle Checkpoint&quot; FALSE [7] &quot;Muscle contraction&quot; FALSE [8] &quot;Activation of ATR in response to replication stress&quot; FALSE [9] &quot;EML4 and NUDC in mitotic spindle formation&quot; FALSE [10] &quot;DNA strand elongation&quot; FALSE [11] &quot;Mitotic Metaphase and Anaphase&quot; FALSE [12] &quot;Mitotic Anaphase&quot; FALSE [13] &quot;RHO GTPases Activate Formins&quot; FALSE [14] &quot;S Phase&quot; FALSE [15] &quot;Homologous DNA Pairing and Strand Exchange&quot; FALSE [16] &quot;Separation of Sister Chromatids&quot; FALSE [17] &quot;HDR through Homologous Recombination (HRR)&quot; FALSE [18] &quot;Synthesis of DNA&quot; FALSE [19] &quot;Activation of the pre-replicative complex&quot; FALSE [20] &quot;Extracellular matrix organization&quot; FALSE [21] &quot;Diseases of DNA repair&quot; FALSE [22] &quot;Diseases of DNA Double-Strand Break Repair&quot; FALSE [23] &quot;Defective homologous recombination repair (HRR) due to BRCA2 loss of function&quot; FALSE [24] &quot;Mitotic G1 phase and G1/S transition&quot; FALSE [25] &quot;M Phase&quot; FALSE [26] &quot;Presynaptic phase of homologous DNA pairing and strand exchange&quot; FALSE [27] &quot;Resolution of D-loop Structures through Holliday Junction Intermediates&quot; FALSE [28] &quot;G1/S Transition&quot; FALSE [29] &quot;Resolution of D-Loop Structures&quot; FALSE [30] &quot;Impaired BRCA2 binding to RAD51&quot; 3.1 barplot The default barplot() from clusterProfiler. barplot(pway, showCategory = 15) 3.2 The vanilla plot This function plots inferred relationship between genes in the specific pathway, with the boot-strapped strength between genes. The normal plot can be plotted by passing the results of clusterProfiler or ReactomePA, and (normalized) expression values as well as candidate samples to be included in the inference. For the pathway including many genes, parallel computing of bootstrap-based inference can be specified with cl parameter. Running bngeneplot in the default parameter. bngeneplot(results = pway, exp = vsted, pathNum = 17) Change the label for the better readability. bngeneplot(results = pway, exp = vsted, pathNum = 17, labelSize=7, shadowText=TRUE) In general, specify samples to be included. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 17) If the resulting network is messy, we can set threshold for the averaged network, which is automatically set by function threshold() from blnearn if not specified. convertSymbol converts the output to SYMBOL. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 17, R = 10, convertSymbol = TRUE, expRow = &quot;ENSEMBL&quot;, strThresh = 0.75) 3.2.1 Show the confidence of direction The value of the confidence of edge direction can be plotted by setting showDir = T. Note that the color represents the strength value. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 50, showDir = T, convertSymbol = T, expRow = &quot;ENSEMBL&quot;, strThresh = 0.7) 3.2.2 Show the hub genes Additionally, showing the hub gene (defined by hub parameter which highlights genes with top-\\(n\\) hub scores) is informative. Weighted Kleinberg’s hub centrality scores are calculated by igraph::hub_score(). bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 50, showDir = T, convertSymbol = T, expRow = &quot;ENSEMBL&quot;, hub=5, strThresh = 0.7) 3.3 The plot with the reference The relationship between genes can be compared with the reference network by the option compareRef=TRUE and specifying pathDb. By default, the intersection of two directed network is shown with the number of overlapping edges. library(parallel) cl = makeCluster(4) bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 30, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, expRow = &quot;ENSEMBL&quot;, cl = cl) We can plot the difference between the reference network by specifying compareRefType=\"difference\". bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;difference&quot;, expRow = &quot;ENSEMBL&quot;) 3.4 The plot with the DepMap information Additionally, DepMap dependency scores can be plotted as the size of nodes using depmap package by specifying sizeDep=TRUE. It is especially useful for cancer-related research. You must provide depmap::depmap_crispr() or the other data describing the dependency score to dep variable. If not, CRISPR scores are downloaded, cached and used. Additionally, the name of cell line interested must be specified. If sizeDep=T, the histogram of overall and within-pathway dependency scores will be plotted besides the network. dep = depmap::depmap_crispr() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 5,compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep) It can be the RNA interference based score. rnai = depmap::depmap_rnai() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 3, R = 5,compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = rnai, cellLineName = &quot;UMUC3_URINARY_TRACT&quot;) Additionally, we can plot the dependency scores of interested genes across the lineage by specifying showLineage=TRUE. We must provide metadata from depmap::depmap_metadata() to depMeta. depMeta = depmap::depmap_metadata() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep, showLineage = T, depMeta = depMeta) 3.5 Plotting edge strengths We can add a barplot depicting the edge strength and direction (probability), by specifying strengthPlot=TRUE and nStrength. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep, strengthPlot = T, nStrength = 10) 3.6 Plotting genes in multiple pathways cl = parallel::makeCluster(8) bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = c(15, 16), R = 10, convertSymbol = T, expRow = &quot;ENSEMBL&quot;) "],["bnpathplot.html", "Chapter 4 bnpathplot 4.1 emapplot 4.2 The vanilla plot 4.3 Compare with the reference 4.4 Reflect DepMap information to pathways 4.5 Aggregating the pathway databases", " Chapter 4 bnpathplot 4.1 emapplot The default emapplot from clusterProfiler. emapplot(pway) 4.2 The vanilla plot This function plots inferred relationship between pathways, with the boot-strapped strength between pathways. The normal plot can be plotted by bnpathplot, passing the results of clusterProfiler or ReactomePA, (normalized) expression values, and candidate rows to be included in the inference. nCategory specifies the number of categories (1:nCategory) to be plotted, sorted by the p-value. expRow indicates what identifiers are used in row names of expression matrix. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, labelSize=5, expRow = &quot;ENSEMBL&quot;) For the messy plot, the label can be modified using shadowText=TRUE. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, labelSize=3, shadowText=TRUE, expRow = &quot;ENSEMBL&quot;) It can be KEGG or GO pathway results using enrichKEGG and enrichGO. bnpathplot(results = pwayGO, exp = vsted, expSample = incSample, nCategory = 30, R = 10, expRow = &quot;ENSEMBL&quot;) Or it can be the GSEA result. bnpathplot(results = pwayGSE, exp = vsted, expSample = incSample, nCategory = 30, R = 10, expRow = &quot;ENSEMBL&quot;, shadowText = TRUE, color = &quot;enrichmentScore&quot;) 4.3 Compare with the reference For Reactome, the relationship between pathways can also be plotted by specifying compareRef=TRUE. Here, dotted lines indicate relationship not in the reference, and solid lines indicate those in the reference. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, compareRef=T, expRow = &quot;ENSEMBL&quot;) 4.4 Reflect DepMap information to pathways We can reflect overall dependency scores for the genes within the pathway by specifying sizeDep=TRUE. You must provide depmap::depmap_crispr or the other data describing the dependency score to dep variable. The average score of the genes in the pathway is used. bnpathplot(results = pwayGO, exp = vsted, expSample = incSample, nCategory = 30, R = 50, sizeDep = T, dep = dep, expRow = &quot;ENSEMBL&quot;) 4.5 Aggregating the pathway databases The multiple GSEA results can be aggregated, by just passing the multiple results like as follows. When choosing the number of categories (nCategory), the order of the results and the numbers should be same. library(DOSE) pwayDO &lt;- enrichDO(gene = cand.entrez) ReaAndDO &lt;- bnpathplot(results = c(pway, pwayDO), exp = vsted, expSample = incSample, nCategory = c(20, 20), R = 50) ReaAndDO "],["including-clinical-variables.html", "Chapter 5 Including clinical variables 5.1 Preparation of data 5.2 Inference of pathway relationship including clinical variables 5.3 Conditional probability query 5.4 Gene relationship with variables 5.5 Confirming the existing knowledge 5.6 Investigating the network based on the clinical question 5.7 Classification using BN", " Chapter 5 Including clinical variables 5.1 Preparation of data One of the important reasons of the Bayesian network analysis is assessing the relationship between gene expressions and clinical variables. CBNplot offers incorporating metadata into inference. As a demonstrative purpose, the enrichment analysis results from GSE133624 is applied on data from The Cancer Genome Atlas Program (TCGA) (Cancer Genome Atlas Research Network et al. 2013). Specifically, TCGA-BLCA data is downloaded by the useful library TCGAbiolinks (Colaprico et al. 2016). library(TCGAbiolinks) ## Load dataset load(file=&quot;tcgablcaData.rda&quot;) We filtered the metadata based on the variables to be included in the inference. In this analysis, age_at_diagnosis and paper_Combined T and LN category, which is a sum of Tumor stage T 1/2 (0) vs. 3/4 (1) and LN negative (0) vs positive (1), are included. We again applied VST on the data. 5.2 Inference of pathway relationship including clinical variables We assess the relationship between the curated biological pathway information and clinical variables mentioned above. Variables other than expression data can be specified with otherVar, as well as otherVarName for their name. The order of otherVar must be same as column order of expression data. We use all the significant pathways of corrected p-values below 0.05. bnCov &lt;- bnpathplot(pway, vstedTCGA, nCategory = 1000, adjpCutOff = 0.01, expSample=rownames(metadata), algo=&quot;hc&quot;, strType=&quot;normal&quot;, otherVar=metadata, otherVarName=c(&quot;Age&quot;, &quot;Category&quot;), R=50, cl=parallel::makeCluster(10), returnNet=T, shadowText=T) ## Check DAG igraph::is.dag(as.igraph(bnCov$av)) FALSE [1] TRUE ## Fit the parameter to network based on the data bnFit &lt;- bn.fit(bnCov$av, bnCov$df) Plot the resulting network. bnCov$plot 5.3 Conditional probability query Next we perform conditional probability queries by the bnlearn function cpdist to elucidate how the clinical variables affect pathway regulation. First we fit the inferred network to the original data. These are stored in the named list. Logic sampling is performed unless otherwise stated. Perform cpdist, and visualize the distribution of “Molecules associated with elastic fibres” conditional on the tumor category using ggdist. library(bnlearn) library(ggdist) library(ggplot2) candPath &lt;- &quot;Molecules associated with elastic fibres&quot; efz &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==0)) efo &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==1)) eft &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==2)) effect = data.frame( val = c(efz[,1], efo[,1], eft[,1]), stage = c(rep(&quot;0&quot;,nrow(efz)), rep(&quot;1&quot;, nrow(efo)), rep(&quot;2&quot;, nrow(eft))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(efz)), rep(stageWMean[2], nrow(efo)), rep(stageWMean[3], nrow(eft))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candPath) How the down-regulation in “Cell Cycle Checkpoints” affects the other pathways? This time using the importance sampling method, likelihood weighting. predNodes &lt;- names(bnFit) predNodes &lt;- predNodes[predNodes != &quot;Cell Cycle Checkpoints&quot;] maxVal &lt;- max(bnCov$df[candPath]) minVal &lt;- min(bnCov$df[candPath]) lowCCC &lt;- cpdist(bnFit, nodes=predNodes, evidence=list(&quot;Cell Cycle Checkpoints&quot;=minVal), method=&quot;lw&quot;) lowW &lt;- attributes(lowCCC)$weights highCCC &lt;- cpdist(bnFit, nodes=predNodes, evidence=list(&quot;Cell Cycle Checkpoints&quot;=maxVal), method=&quot;lw&quot;) highW &lt;- attributes(highCCC)$weights ## Remove the factor highCCC$Category &lt;- NULL lowCCC$Category &lt;- NULL difMeanCCC &lt;- apply(highCCC, 2, function(x) weighted.mean(x, highW)) - apply(lowCCC, 2, function(x) weighted.mean(x, lowW)) ## Top absolute value kable(head(difMeanCCC[order(abs(difMeanCCC), decreasing=TRUE)]), col.names=c(&quot;difference&quot;)) difference M Phase 23.15520 Mitotic Prometaphase 20.93115 Mitotic Metaphase and Anaphase 20.70000 Mitotic Anaphase 20.56985 Separation of Sister Chromatids 19.35587 Resolution of Sister Chromatid Cohesion 19.16356 ## Reflect the difference in the plot modifying ggplot2 object changeCol &lt;- bnCov$plot$data difMeanCCC &lt;- difMeanCCC[changeCol$name] names(difMeanCCC) &lt;- changeCol$name changeCol$color &lt;- difMeanCCC ## Replace the color, change the legend bnCov$plot$data &lt;- changeCol bnCov$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) 5.4 Gene relationship with variables For the genes in interesting pathway, clinical variables can be incorporated too. We investigated the genes involved in the reactome “Molecules associated with elastic fibres”. num &lt;- which(pway@result$Description==&quot;Molecules associated with elastic fibres&quot;) bnGeneCov &lt;- bngeneplot(pway, vstedTCGA, pathNum=num, expSample=rownames(metadata), otherVar=metadata, hub=5, R=100, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) Plot the resulting network of genes. ## Plot bnGeneCov$plot ## Check DAG igraph::is.dag(as.igraph(bnGeneCov$av)) FALSE [1] TRUE ## Fit the parameter to network based on the data bnFitGene &lt;- bn.fit(bnGeneCov$av, bnGeneCov$df) Perform cpdist, and examine the mean and distribution using ggdist. We can see that the expression of the gene EFEMP1, which is reported to be a candidate for a biomarker of aggressive bladder cancer or therapeutic targets (Han et al. 2017), is going up with each stage. candGene &lt;- &quot;EFEMP1&quot; efz &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==0)) efo &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==1)) eft &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==2)) effect = data.frame( val = c(efz[,1], efo[,1], eft[,1]), stage = c(rep(&quot;0&quot;,nrow(efz)), rep(&quot;1&quot;, nrow(efo)), rep(&quot;2&quot;, nrow(eft))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(efz)), rep(stageWMean[2], nrow(efo)), rep(stageWMean[3], nrow(eft))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) We can reflect the difference to the plot. In the previous EFEMP1 plot: candGene &lt;- names(bnFitGene) candGene &lt;- candGene[candGene != &quot;Category&quot;] efz2 &lt;- cpdist(bnFitGene, nodes=candGene, evidence=(Category==0)) eft2 &lt;- cpdist(bnFitGene, nodes=candGene, evidence=(Category==2)) difMean &lt;- apply(eft2, 2, mean) - apply(efz2, 2, mean) changeCol &lt;- bnGeneCov$plot$data difMean &lt;- difMean[changeCol$name] names(difMean) &lt;- changeCol$name changeCol$color &lt;- difMean ## Replace shape and color changeCol$shape &lt;- rep(19, dim(bnGeneCov$plot$data)[1]) bnGeneCov$plot$data &lt;- changeCol bnGeneCov$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) 5.5 Confirming the existing knowledge To confirm the validity of the inferred Bayesian network, we can focus on some genes that is already validated to be related to clinical information or is incorporated into the daily clinical practice. To obtain the pathways that include the specific gene, one can use obtainPath function. This time we focus on the gene MMP2, as the gene has been reported to be related to clinical variables in bladder cancer (Vasala, Pääkkö, and Turpeenniemi-Hujanen 2003; Fouad et al. 2019; Winerdal et al. 2018). pathSub &lt;- obtainPath(pway, &quot;MMP2&quot;) Using the top pathway involving MMP2, construct the network and plot. bnGeneCov2 &lt;- bngeneplot(pathSub, vstedTCGA, pathNum=1, expSample=rownames(metadata), otherVar=metadata, hub=5, R=100, algo=&quot;hc&quot;, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnGeneCov2$plot bnGeneCov2Fit &lt;- bn.fit(bnGeneCov2$av, bnGeneCov2$df) Predict the distribution. candGene &lt;- &quot;MMP2&quot; mz &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==0), method=&quot;ls&quot;) mo &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==1), method=&quot;ls&quot;) mt &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==2), method=&quot;ls&quot;) effect = data.frame( val = c(mz[,1], mo[,1], mt[,1]), stage = c(rep(&quot;0&quot;,nrow(mz)), rep(&quot;1&quot;, nrow(mo)), rep(&quot;2&quot;, nrow(mt))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(mz)), rep(stageWMean[2], nrow(mo)), rep(stageWMean[3], nrow(mt))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) It is interesting to investigate whether the result is similar in the other database, like Gene Ontology doing the same analysis. ## Perform the same analysis on GO enrichment result pathSubGO &lt;- obtainPath(pwayGO, &quot;MMP2&quot;) pathSubGO@result[1:5, c(&quot;Description&quot;,&quot;geneID&quot;,&quot;Count&quot;)] FALSE Description FALSE GO:0001968 fibronectin binding FALSE GO:0004222 metalloendopeptidase activity FALSE GO:0008237 metallopeptidase activity FALSE GO:0004252 serine-type endopeptidase activity FALSE GO:0008236 serine-type peptidase activity FALSE geneID FALSE GO:0001968 MYOC/FSTL3/FBLN1/MMP2/CCDC80/VEGFA/CCN2/THBS1/SFRP2/EPHA1/IGFBP6/LRRC15/SSC5D FALSE GO:0004222 NRDC/MMP2/MMP11/ADAM2/COPS5/NLN/MMP19/MMP24/ADAMTS8/MMP27/MMP13/ADAM10/ECE2/ADAM33/ADAM17/ADAMTS1/ADAMTS5/ADAMTS4/MMP10/ADAMTS20/PAPPA/LMLN/MMP23B/MMP1/TRABD2B FALSE GO:0008237 NAALAD2/NRDC/MMP2/MMP11/CPQ/ADAM2/PSMD14/COPS5/CPXM2/XPNPEP2/NLN/MMP19/STAMBP/MMP24/CPA4/ADAMTS8/MMP27/MMP13/ADAM10/ECE2/ADAM33/ADAM17/ADAMTS1/ADAMTS5/ADAMTS4/MYSM1/CPA3/MMP10/ADAMTS20/PAPPA/LMLN/MMP23B/MMP1/TRABD2B FALSE GO:0004252 LTF/MMP2/CMA1/TPSD1/MMP11/ACR/CTSG/GZMH/GZMK/TPSG1/MMP19/PCSK2/F10/MASP1/F12/CTSV/MMP13/C1R/MMP10/KLK6/TPSAB1/C1S/MMP1/TPSB2/GZMM/ELANE/CFD FALSE GO:0008236 LTF/NAALAD2/MMP2/CMA1/TPSD1/MMP11/ACR/CTSG/GZMH/CPVL/GZMK/TPSG1/MMP19/PCSK2/F10/MASP1/F12/CTSV/MMP13/C1R/MMP10/KLK6/TPSAB1/C1S/MMP1/TPSB2/GZMM/ELANE/CFD FALSE Count FALSE GO:0001968 13 FALSE GO:0004222 25 FALSE GO:0008237 34 FALSE GO:0004252 27 FALSE GO:0008236 29 num &lt;- 1:2 bnCovGO &lt;- bngeneplot(pathSubGO, vstedTCGA, pathNum=num, algo=&quot;hc&quot;, expSample=rownames(metadata), otherVar=metadata, R=300, layout=&quot;sugiyama&quot;, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=TRUE) bnCovGO$av$nodes$Category FALSE $mb FALSE [1] &quot;CCDC80&quot; FALSE FALSE $nbr FALSE [1] &quot;CCDC80&quot; FALSE FALSE $parents FALSE character(0) FALSE FALSE $children FALSE [1] &quot;CCDC80&quot; bnGeneCovGOFit &lt;- bn.fit(bnCovGO$av, bnCovGO$df) mz &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==0), method=&quot;ls&quot;) mo &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==1), method=&quot;ls&quot;) mt &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==2), method=&quot;ls&quot;) effect = data.frame( val = c(mz[,1], mo[,1], mt[,1]), stage = c(rep(&quot;0&quot;,nrow(mz)), rep(&quot;1&quot;, nrow(mo)), rep(&quot;2&quot;, nrow(mt))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(mz)), rep(stageWMean[2], nrow(mo)), rep(stageWMean[3], nrow(mt))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) + labs(caption=paste(pathSubGO@result$Description[num], collapse=&quot;\\n&quot;)) 5.6 Investigating the network based on the clinical question After confirming the knowledge, it is interesting to test how difference in clinical variables affect gene expression. bnlearn can naturally handle this again using cpdist. We now include two more variables, age_at_diagnosis, gender, paper_Noninvasive.bladder.cancer.therapy, paper_Combined.T.and.LN.category. Inference based on these information, we can ask: Which genes have the biggest expression differences between those treated with BCG and with none, considering the networks of genes and clinical variables of age, gender, tumor category in TCGA-BLCA dataset using genes significantly differed in GSE133624 and involved in curated biological pathways related to MMP2? ## Subset to significant pathways, and those related to MMP2 pway@result &lt;- subset(pway@result, p.adjust&lt;0.05) pathSub &lt;- obtainPath(pway, &quot;MMP2&quot;) bnCovGene3 &lt;- bngeneplot(pathSub, vstedBCG, pathNum = seq_len(nrow(pathSub)), expSample=rownames(metadata), otherVar=metadata, hub=5, R=50, otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;Therapy&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnCovGene3Fit &lt;- bn.fit(bnCovGene3$av, bnCovGene3$df) allGenes &lt;- names(bnCovGene3$av$nodes) allGenes &lt;- allGenes[!allGenes %in% c(&quot;Age&quot;,&quot;Gender&quot;,&quot;Therapy&quot;,&quot;Category&quot;)] no &lt;- cpdist(bnCovGene3Fit, nodes=allGenes, evidence=(Therapy==&quot;none&quot;), method=&quot;ls&quot;) bcg &lt;- cpdist(bnCovGene3Fit, nodes=allGenes, evidence=(Therapy==&quot;Bacillus Calmette.Guerin (BCG)&quot;), method=&quot;ls&quot;) difMean &lt;- data.frame(apply(bcg, 2, mean)-apply(no, 2, mean)) difMean$name &lt;- rownames(difMean) colnames(difMean) &lt;- c(&quot;difference&quot;,&quot;name&quot;) difMean &lt;- difMean[order(abs(difMean$difference), decreasing=T),] kable(head(difMean, n=5)) difference name COL25A1 0.2344216 COL25A1 MFAP5 0.1834830 MFAP5 COL11A1 0.1494830 COL11A1 COL10A1 0.1381034 COL10A1 LAMC2 -0.1340511 LAMC2 5.7 Classification using BN Inferred BN can be used as a classifier of conditions. In this analysis, we perform the classification of whether the cancer samples are harboring TP53 mutation or not (column paper_mutation in TP53). First, we make a metadata table as same as the above examples. metadata &lt;- data.frame(tcgaData@colData) %&gt;% dplyr::select(age_at_diagnosis, gender, paper_mutation.in.TP53, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_mutation.in.TP53!=&quot;ND&quot;) %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) table(metadata$paper_mutation.in.TP53) FALSE FALSE no yes FALSE 184 163 ## Set TP53 status to numeric of 0/1. metadata$paper_mutation.in.TP53 &lt;- as.numeric(as.factor(metadata$paper_mutation.in.TP53))-1 metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) metadata$gender &lt;- as.factor(metadata$gender) Split the data to train/test according to TP53 mutation status using caret (Kuhn 2008). In this analysis, the five-fold cross validation (stratified) is performed. Fit the model using the expression of genes in the pathway. This time the classification performance of significant pathways (corrected p &lt; 1e-5) are to be compared. onlyDf option can be enabled to return only the data.frame containing data for prediction, useful for testing purpose, and using the resulting data for the other softwares. set.seed(53) # Seed for split trainIndex &lt;- caret::createFolds(factor(metadata$paper_mutation.in.TP53), k = 5, list = TRUE, returnTrain=TRUE) allnets &lt;- list() ## Store network in the list allClassRes &lt;- list() ## Store prediction in the list ## Already VSTed DF load(&quot;trainDf.rda&quot;) load(&quot;testDf.rda&quot;) for (f in seq_len(5)) { nets &lt;- list() classRes &lt;- list() foldTrainIndex &lt;- trainIndex[[f]] ## Recursively fit and test for significant pathways for (pnum in seq(1, dim(subset(pway@result, p.adjust&lt;1e-5))[1], 1)) { cl &lt;- parallel::makeCluster(12) bnCovTrain &lt;- bngeneplot(pway, assay(trainDf[[f]]), pathNum=pnum, layout=&quot;sugiyama&quot;, expSample=rownames(metadata[foldTrainIndex,]), algo=&quot;hc&quot;, strType=&quot;normal&quot;, otherVar=metadata[foldTrainIndex,], otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;TP53&quot;,&quot;Category&quot;), R=50, cl=cl, returnNet=T) ## Return only DF for testing bnCovTest &lt;- bngeneplot(pway, assay(testDf[[f]]), pathNum=pnum, expSample=rownames(metadata[-foldTrainIndex,]), otherVar=metadata[-foldTrainIndex,], otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;TP53&quot;,&quot;Category&quot;), onlyDf=T) ## If DAG and TP53 have parents if ( igraph::is.dag(bnlearn::as.igraph(bnCovTrain$av)) &amp;&amp; length(bnCovTrain$av$nodes$TP53$parents) &gt;= 1 ){ bnCovLargeFit &lt;- bnlearn::bn.fit(bnCovTrain$av, bnCovTrain$df) pred &lt;- sigmoid::sigmoid(predict(bnCovLargeFit, node=&quot;TP53&quot;, data=bnCovTest, method = &quot;bayes-lw&quot;)) # Use sigmoid function classRes[[pway@result$Description[pnum]]] &lt;- pred nets[[pway@result$Description[pnum]]] &lt;- bnCovTrain } else { message(paste0(&quot;Among pathway &quot;, pway@result$Description[pnum], &quot;, no parent node of TP53 is found, or inferred network is not dag.&quot;)) } parallel::stopCluster(cl) } allnets[[f]] &lt;- nets allClassRes[[f]] &lt;- classRes } Using the library pROC, calculate the area under ROC (auROC) (Robin et al. 2011). library(pROC) library(ggplotify) rocDf &lt;- c() allRocList &lt;- list() for (f in seq_len(5)) { correct &lt;- metadata[-trainIndex[[f]],]$paper_mutation.in.TP53 predDf &lt;- data.frame(allClassRes[[f]]) predDf$label &lt;- correct rocList &lt;- list() for (i in seq_len(dim(predDf)[2]-1)){ rocList[[names(predDf)[i]]] &lt;- roc(predDf$label, predDf[,i], ci=TRUE, direction=&quot;&lt;&quot;) # check direction } tmpRocDf &lt;- data.frame(t(data.frame(purrr::map(rocList, function(x) as.numeric(x$auc))))) colnames(tmpRocDf) &lt;- c(paste0(&quot;auc&quot;,f)) tmpRocDf$name &lt;- rownames(tmpRocDf) allRocList[[f]] &lt;- tmpRocDf } allRocListDf &lt;- allRocList %&gt;% purrr::reduce(left_join, by = &quot;name&quot;) rocMean &lt;- allRocListDf %&gt;% rowwise() %&gt;% mutate(Min = min(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Max = max(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Mean = mean(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Sd = sd(c_across(starts_with(&quot;auc&quot;)), na.rm=T)) %&gt;% select(name ,Mean, Sd) %&gt;% arrange(desc(Mean)) kable(rocMean, row.names=FALSE, booktab=TRUE) %&gt;% kable_styling(font_size = 10) name Mean Sd DNA.strand.elongation 0.7586171 0.0476902 S.Phase 0.7442158 0.0417892 RHO.GTPases.Activate.Formins 0.7361936 0.0372955 Activation.of.ATR.in.response.to.replication.stress 0.7313293 0.0309443 Amplification..of.signal.from.unattached..kinetochores.via.a.MAD2..inhibitory.signal 0.7298620 0.0356467 Resolution.of.Sister.Chromatid.Cohesion 0.7245308 0.0627438 Homologous.DNA.Pairing.and.Strand.Exchange 0.7236192 0.0361203 HDR.through.Homologous.Recombination..HRR. 0.7108159 0.0408204 EML4.and.NUDC.in.mitotic.spindle.formation 0.6847067 0.0969711 Mitotic.Spindle.Checkpoint 0.6727978 0.0843631 Separation.of.Sister.Chromatids 0.5731690 0.1567807 Show the resulting network with the top auROC, and the ROC plot using pROC (Robin et al. 2011). topPath &lt;- rocMean[1,&quot;name&quot;] candFold &lt;- as.numeric(allRocListDf %&gt;% filter(name == as.character(topPath)) %&gt;% summarize(which.max(c_across(starts_with(&quot;auc&quot;))))) ## With the CI candRoc &lt;- data.frame(metadata[-trainIndex[[candFold]],]$paper_mutation.in.TP53) colnames(candRoc) &lt;- c(&quot;label&quot;) candRoc$pred &lt;- as.numeric(unlist(allClassRes[[candFold]][gsub(&quot;[.]&quot;, &quot; &quot;, as.character(topPath))])) rocobj1 &lt;- plot.roc(candRoc$label, candRoc$pred, print.auc = TRUE, ci=TRUE, col=&quot;black&quot;, direction=&quot;&lt;&quot;, main = &quot;Mutation in TP53&quot;, percent=TRUE) ciobj &lt;- ci.se(rocobj1, specificities = seq(0, 100, 5), progress=&quot;none&quot;) plot(ciobj, type = &quot;shape&quot;, col = &quot;steelblue&quot;) ## Along with the network topNet &lt;- allnets[[candFold]][[gsub(&quot;[.]&quot;, &quot; &quot;, topPath)]] topNet$plot Using bnlearn::cpdist, check the difference in the distribution mean when the value of the node TP53 is above and below 0.5. topFit &lt;- bnlearn::bn.fit(topNet$av, topNet$df) candNodes &lt;- names(topNet$av$nodes) candNodes &lt;- candNodes[!candNodes %in% c(&quot;TP53&quot;,&quot;Category&quot;,&quot;Gender&quot;)] tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &lt; 0.5)) dim(tp53low) FALSE [1] 5225 21 tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &gt; 0.5)) dim(tp53high) FALSE [1] 4717 21 difMeanTp53 &lt;- apply(tp53high, 2, mean) - apply(tp53low, 2, mean) kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM2 0.3978904 RFC4 0.3534718 MCM8 0.3250150 PRIM1 0.3243060 PRIM2 0.3031842 GINS4 0.2868035 changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) When the TP53 takes the extreme values on logic sampling. topFit &lt;- bnlearn::bn.fit(topNet$av, topNet$df) candNodes &lt;- names(topNet$av$nodes) candNodes &lt;- candNodes[!candNodes %in% c(&quot;TP53&quot;,&quot;Category&quot;,&quot;Gender&quot;)] tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &lt; 0.01)) dim(tp53low) FALSE [1] 1760 21 tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &gt; 0.99)) dim(tp53high) FALSE [1] 1552 21 difMeanTp53 &lt;- apply(tp53high, 2, mean) - apply(tp53low, 2, mean) kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM2 0.7375946 RFC4 0.6955627 MCM8 0.5989058 PRIM1 0.5895650 PRIM2 0.5783348 GINS1 0.4874811 changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) Perform likelihood weighting. tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=list(TP53 = 0), method=&quot;lw&quot;) tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=list(TP53 = 1), method=&quot;lw&quot;) difMeanTp53 &lt;- apply(tp53high, 2, function(x) weighted.mean(x, attributes(tp53high)$weights)) - apply(tp53low, 2, function(x) weighted.mean(x, attributes(tp53low)$weights)) changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM2 0.5113805 RFC4 0.4569469 MCM8 0.4353333 PRIM1 0.4136929 PRIM2 0.3935092 GINS1 0.3680252 names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) queryCpDistLw function performs sampling by likelihood weighting using cpdist, and returns the data.frame with weights. It just performs cpdist on the queried level and produce a plot. queryCpDistLs performs logic sampling. ## Only likelihood weighting is supported in queryCpDist. q1 &lt;- queryCpDistLw(topFit, names(difMeanTp53)[1], evidence=&quot;TP53&quot;, level=c(0,0.5,1)) kable(head(q1$df[,c(names(difMeanTp53)[1],&quot;weights&quot;)])) RFC2 weights 11.29786 0.8774882 10.16672 0.3570390 10.30900 0.2065809 10.82745 0.8837212 10.36271 0.8340634 10.50688 0.7633695 References "],["the-other-options.html", "Chapter 6 The other options 6.1 Using microbiome-related data 6.2 Discretization 6.3 Custom visualization 6.4 Comparing multi scale and standard bootstrapping", " Chapter 6 The other options 6.1 Using microbiome-related data library(MicrobiomeProfiler) data(Rat_data) ko.res &lt;- enrichKO(Rat_data) exp.dat &lt;- matrix(abs(rnorm(910)), 91, 10) %&gt;% magrittr::set_rownames(value=Rat_data) %&gt;% magrittr::set_colnames(value=paste0(&#39;S&#39;, seq_len(ncol(.)))) exp.dat %&gt;% head FALSE S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 FALSE K01809 1.0258585 0.5548567 0.4003436 0.6788078 1.13371970 1.41151243 1.8440381 0.97353206 0.5043282 0.2380309 FALSE K00688 0.7298670 0.6963865 1.5619467 0.9205528 0.58716102 0.68760125 0.6945185 0.44622843 1.6735640 1.2809780 FALSE K03388 1.1478900 0.9874183 1.0948022 1.0291543 1.29837354 0.06679942 0.5559601 1.52744298 0.9055871 0.5562262 FALSE K01632 0.7745596 1.3905860 0.8923063 0.3546186 0.52034390 0.60359780 0.3164442 0.06439157 0.3197770 1.1025949 FALSE K07406 0.1379650 0.3549818 1.4843694 0.4554946 0.01794059 2.26569784 0.7371879 1.14979456 1.7924435 0.5045444 FALSE K02991 1.3290375 3.0380460 0.5802602 1.4522863 0.79960704 0.33474238 1.6461427 0.06828655 1.0537423 0.4053420 library(CBNplot) bngeneplot(ko.res, exp=exp.dat, pathNum=1, orgDb=NULL) 6.2 Discretization If passed an option disc=TRUE, the continuous variables are discretized using arules::discretize function (Hahsler et al. 2011). The discretization of the gene expression data is discussed in Gallo et al. (2016). If the same discretization is to be applied on the other data like the training and test dataset, you can pass the training samples to tr option, and if some variables are not intended to be discretized, you should pass the column name to remainCont. bngeneplot(results = pway, exp = vsted, pathNum = 1, disc=TRUE, layout=&quot;sugiyama&quot;) 6.3 Custom visualization 6.3.1 The glowing nodes and edges In addition to the normal plot, custom function of visualization is implemented (bngeneplotCustom and bnpathplotCustom). For example, to effectively visualize the hub genes and edges with high strength by glowing the respective nodes and edges, below is an example using an idea of ggCyberPunk. Additionally, the edge and node colors are fully customizable. cl = parallel::makeCluster(6) bngeneplotCustom(results = pway, exp = vsted, expSample = incSample, R=50, cl=cl, layout=&quot;nicely&quot;, fontFamily=&quot;sans&quot;, pathNum = c(4), strType=&quot;normal&quot;, sizeDep=TRUE, dep=dep, showDir=FALSE, hub=5, glowEdgeNum=5, strThresh=0.6, strengthPlot = TRUE) For the demonstrative purpose, using the palettes and fonts of vapoRwave and showtext, the other visualizations are possible. Note that in custom visualization, only the network plot and strength barplot are supported. ## Use alien encounter fonts (http://www.hipsthetic.com/alien-encounters-free-80s-font-family/) sysfonts::font_add(family=&quot;alien&quot;,regular=&quot;SFAlienEncounters.ttf&quot;) showtext::showtext_auto() cl = parallel::makeCluster(6) bngeneplotCustom(results = pway, exp = vsted, expSample = incSample, R=20, cl=cl, fontFamily=&quot;alien&quot;, labelSize=6, pathNum = c(15), strType=&quot;normal&quot;, showDir=F, hub=5, glowEdgeNum=5, strThresh=0.6, strengthPlot = T, sizeDep=F, dep=dep, layout=&quot;kk&quot;, edgePal=c(&quot;#9239F6&quot;,&quot;#FF4373&quot;), nodePal=c(&quot;#F8B660&quot;,&quot;#FF0076&quot;), barLegendKeyCol=&quot;#0F0D1A&quot;, textCol=&quot;#EE9537&quot;, titleCol=&quot;#EE9537&quot;, backCol=&quot;#0F0D1A&quot;, barAxisCol=&quot;#EE9537&quot;, barTextCol=&quot;#EE9537&quot;, barPal=c(&quot;#9239F6&quot;, &quot;#FF4373&quot;), barPanelGridCol=&quot;#FFB967&quot;, barBackCol=&quot;#0F0D1A&quot;, titleSize=14 ) parallel::stopCluster(cl) 6.4 Comparing multi scale and standard bootstrapping cl &lt;- parallel::makeCluster(6) comparePlot &lt;- bngeneplot(results = pway, exp = vsted, cl=cl, strType=&quot;normal&quot;, pathNum = 15, R = 50, returnNet=T, shadowText = TRUE) comparePlotMS &lt;- bngeneplot(results = pway, exp = vsted, cl=cl, strType=&quot;ms&quot;, pathNum = 15, R = 50, returnNet=T, shadowText = TRUE) kable(comparePlot$str %&gt;% filter(direction&gt;0.5) %&gt;% arrange(desc(strength)) %&gt;% head()) from to strength direction TOPBP1 ATR 0.9814815 0.8657407 BRCA1 RAD51AP1 0.9629630 0.5243056 ATR RFC2 0.9444444 0.5648148 RFC5 XRCC3 0.9074074 0.5160384 CHEK1 RAD51 0.8518519 0.8022487 RAD51AP1 CHEK1 0.8333333 0.7468585 kable(comparePlotMS$str %&gt;% filter(direction&gt;0.5) %&gt;% arrange(desc(strength)) %&gt;% head()) from to strength direction BRCA1 RAD51AP1 0.9974312 0.5885859 RFC2 ATR 0.9968008 0.6932430 BRIP1 BRCA2 0.9922096 0.7125908 DNA2 BLM 0.9903698 0.5422446 BLM DNA2 0.9903698 0.8090673 TOPBP1 RMI1 0.9892198 0.5154026 References "],["comparing-networks.html", "Chapter 7 Comparing networks 7.1 Comparing multiple networks 7.2 Testing R", " Chapter 7 Comparing networks 7.1 Comparing multiple networks The inference including hundreds of genes should be interpreted with caution especially for the low bootstrap number. For assessing the network stability, the users can compare and output F-measure by the function compareBNs, which accepts the list of multiple networks (bn) and output the pairwise F-measures. In this analysis, We perform the inference five times for 100 and 500 bootstrap numbers in the specific reactome. fvres &lt;- c() cl &lt;- parallel::makeCluster(12) for (R in c(200,500)){ n1 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n2 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n3 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n4 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n5 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) geneNum &lt;- length(n1$av$nodes) nets &lt;- list(n1$av, n2$av, n3$av, n4$av, n5$av) igList &lt;- list(as.igraph(n1$av), as.igraph(n2$av), as.igraph(n3$av), as.igraph(n4$av), as.igraph(n5$av)) allnets &lt;- nets fvalues &lt;- compareBNs(nets) fvres &lt;- rbind(fvres, c(&quot;TCGA&quot;, 13, geneNum, R, &quot;default&quot;, mean(fvalues), sd(fvalues))) ## Threshold 0.8 n1av &lt;- averaged.network(n1$str, threshold=0.8) n2av &lt;- averaged.network(n2$str, threshold=0.8) n3av &lt;- averaged.network(n3$str, threshold=0.8) n4av &lt;- averaged.network(n4$str, threshold=0.8) n5av &lt;- averaged.network(n5$str, threshold=0.8) nets &lt;- list(n1av, n2av, n3av, n4av, n5av) fvalues &lt;- compareBNs(nets) fvres &lt;- rbind(fvres, c(&quot;TCGA&quot;, 13, geneNum, R, 0.8, mean(fvalues), sd(fvalues))) } resDF &lt;- data.frame(fvres) colnames(resDF) &lt;- c(&quot;dataset&quot;,&quot;path_number&quot;,&quot;gene_number&quot;,&quot;R&quot;,&quot;threshold&quot;,&quot;mean&quot;,&quot;sd&quot;) pathway_name &lt;- sapply(resDF$path_number, function(x) pway@result$Description[as.numeric(x)]) resDF$label &lt;- paste0(resDF$gene_number, &quot;\\n(&quot;, stringr::str_wrap(pathway_name,10),&quot;)&quot;) parallel::stopCluster(cl) kable(resDF) dataset path_number gene_number R threshold mean sd label TCGA 13 48 200 default 0.879001362810166 0.0268588783377082 48 (RHO GTPases Activate Formins) TCGA 13 48 200 0.8 0.910779196545874 0.0154934340979147 48 (RHO GTPases Activate Formins) TCGA 13 48 500 default 0.910205528150544 0.00830851399185569 48 (RHO GTPases Activate Formins) TCGA 13 48 500 0.8 0.936679898625571 0.0195192542150308 48 (RHO GTPases Activate Formins) Plot the result for the visual assessment. defa &lt;- resDF %&gt;% filter(threshold==&quot;default&quot;) %&gt;% ggplot(aes(x=label, y=as.numeric(mean), group=dataset, color=dataset, bg.color=dataset, segment.color=dataset) )+ geom_jitter(size=4, width=0.1) + theme_minimal() + geom_text_repel(aes(label = R), color = &quot;white&quot;, size=4, bg.r = .15) + scale_color_brewer(palette = &quot;Set1&quot;, name = &quot;Dataset&quot;, # The same color scall will apply to both of these aesthetics. aesthetics = c(&quot;color&quot;,&quot;bg.color&quot;,&quot;segment.color&quot;))+ geom_hline(yintercept=0.8, lty=3, color=&quot;red&quot;, size=1) + xlab(&quot;Gene number&quot;) + ylab(&quot;F-measure&quot;) + ggtitle(&quot;Default strength threshold&quot;) high &lt;- resDF %&gt;% filter(threshold==&quot;0.8&quot;) %&gt;% ggplot(aes(x=label, y=as.numeric(mean), group=dataset, color=dataset, bg.color=dataset, segment.color=dataset) )+ geom_jitter(size=4, width=0.1) + theme_minimal() + geom_text_repel(aes(label = R), color = &quot;white&quot;, size=4, bg.r = .15) + scale_color_brewer(palette = &quot;Set1&quot;, name = &quot;Dataset&quot;, # The same color scall will apply to both of these aesthetics. aesthetics = c(&quot;color&quot;,&quot;bg.color&quot;,&quot;segment.color&quot;))+ geom_hline(yintercept=0.8, lty=3, color=&quot;red&quot;, size=1) + xlab(&quot;Gene number&quot;) + ylab(&quot;F-measure&quot;) + ggtitle(&quot;Strength threshold = 0.8&quot;) defa / high Take the intersection of networks. as.bn(Reduce(igraph::intersection, igList)) FALSE FALSE Random/Generated Bayesian network FALSE FALSE model: FALSE [NUP107][CDC20][KNL1][KIF2C|CDC20][BUB1B|KNL1][BIRC5|CDC20:KIF2C][CENPF|KNL1:KIF2C:BUB1B] FALSE [CDCA8|CDC20:KIF2C][ZWILCH|KNL1:BUB1B][CENPA|BIRC5:CDCA8:KIF2C][CENPE|CENPF:KNL1:BUB1B] FALSE [BUB1|CENPF:KIF2C:BUB1B][AURKB|BIRC5:CDC20][CENPI|CDCA8:KNL1:CENPE][KIF18A|CENPE:AURKB] FALSE [CENPK|CENPE:BUB1B][NUP85|BIRC5:CENPE][SPC25|BIRC5:AURKB][MAD2L1|BIRC5:CENPE:ZWILCH] FALSE [SPDL1|CENPK:BUB1B][DSN1|NUP85:KIF2C][SPC24|BIRC5:KIF2C:SPC25:AURKB] FALSE [SGO2|KIF18A:KNL1:BUB1:AURKB][PLK1|BIRC5:CENPA:CDC20:SPC25][TUBA1C|CDC20:SPC25] FALSE [NUP133|CENPF:CENPE:SPC24][SRF|TUBA1C][SGO1|TUBA1C:BUB1][CENPU|DSN1:MAD2L1] FALSE [CENPH|BIRC5:CENPA:CENPK:SPC25:SPC24:MAD2L1:ZWILCH] FALSE [KNTC1|BIRC5:CENPK:NUP85:KNL1:CENPE:DSN1][NUP37|CENPF:CENPH:TUBA1C:ZWILCH:KNTC1] FALSE [CENPO|CENPA:NUP85:CENPU:MAD2L1][RHOB|SRF:SGO1][INCENP|CDCA8:KNL1:CENPH:SPC24:MAD2L1:BUB1] FALSE [SKA1|BIRC5:SGO1:SPC24:BUB1:ZWILCH][CKAP5|NUP133:KIF18A:DSN1] FALSE [NDC80|CENPA:CENPK:SKA1:SPC24:MAD2L1:AURKB][XPO1|CENPO:CENPE:SPC24:SGO2] FALSE [NUF2|CENPA:CENPF:SGO1:SKA1:TUBA1C:AURKB][BUB3|NUP37][ERCC6L|CENPI:SRF:SGO1:SKA1:TUBA1C] FALSE [CENPQ|NUP37:NDC80:CENPI:MAD2L1][ZWINT|NDC80:SGO1:DSN1][DIAPH3|NDC80:CENPI:SRF:SGO2] FALSE [AHCTF1|NDC80:BIRC5:CENPF:CENPE][CENPL|XPO1:CENPO:NUF2:DSN1:AHCTF1:CKAP5] FALSE [RCC2|NUP133:CENPI:CENPF:CDCA8:DIAPH3:CENPU:BUB1] FALSE nodes: 48 FALSE arcs: 150 FALSE undirected arcs: 0 FALSE directed arcs: 150 FALSE average markov blanket size: 12.42 FALSE average neighbourhood size: 6.25 FALSE average branching factor: 3.12 FALSE FALSE generation algorithm: Empty The same can be done for bnpathplot. cl &lt;- parallel::makeCluster(12) n1 &lt;- bnpathplot(pway, vstedTCGA, nCategory = 15, returnNet=T, R=200, cl=cl) n2 &lt;- bnpathplot(pway, vstedTCGA, nCategory = 15, returnNet=T, R=200, cl=cl) n3 &lt;- bnpathplot(pway, vstedTCGA, nCategory = 15, returnNet=T, R=200, cl=cl) n4 &lt;- bnpathplot(pway, vstedTCGA, nCategory = 15, returnNet=T, R=200, cl=cl) n5 &lt;- bnpathplot(pway, vstedTCGA, nCategory = 15, returnNet=T, R=200, cl=cl) nets &lt;- list(n1$av, n2$av, n3$av, n4$av, n5$av) fvalues &lt;- compareBNs(nets) mean(fvalues) FALSE [1] 0.9752001 parallel::stopCluster(cl) 7.2 Testing R We provide the diagnostic function of inferred network across multiple bootstrap numbers. We can test how R values affect the resulting network. It is very time consuming to test many genes, thus the setting up cl argument using library parallel is suggested. We can specify which scoring function to use by scoreType. Additionally, returned strength data frame as well as raw data frame can be used to assess various metrics and thresholds like structural hamming distance. cl &lt;- parallel::makeCluster(6) pathTest &lt;- bnpathtest(results = pway, algo=&quot;hc&quot;, exp = vsted, Rrange = seq(10, 300, 10), nCategory = 15, expSample = incSample, expRow = &quot;ENSEMBL&quot;, cl = cl) # Plot difEdges &lt;- sapply(pathTest$graph, function(x) sapply(pathTest$graph, function(y) length(E(difference(as.igraph(x), as.igraph(y)))))) difEdges &lt;- data.frame(difEdges[dim(difEdges)[1], colnames(difEdges)]) colnames(difEdges) &lt;- c(&quot;NumDif&quot;) ggplot(difEdges, aes(x=as.numeric(substring(rownames(difEdges), 2)), y=NumDif)) + geom_line(group=1)+ geom_point(aes(color=NumDif), size=5)+ scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, name=&quot;Number of different edges&quot;, guide = guide_legend())+ theme_bw()+xlab(&quot;R&quot;)+ylab(&quot;Number of different edges&quot;)+ theme(legend.position=&quot;bottom&quot;) parallel::stopCluster(cl) ## Which pathway? paste(pway@result[15,]$Description, pway@result[15,]$Count) FALSE [1] &quot;Homologous DNA Pairing and Strand Exchange 22&quot; ## From 10 to 200 cl = parallel::makeCluster(6) geneTest &lt;- bngenetest(results = pway, algo=&quot;hc&quot;, pathNum=15, exp = vsted, Rrange=seq(10, 200, 10), expSample = incSample, expRow = &quot;ENSEMBL&quot;, cl = cl) difSHD &lt;- sapply(geneTest$graph, function(x) sapply(geneTest$graph, function(y) shd(x, y))) # Plot SHD compared to the highest R network difSHD &lt;- data.frame(difSHD[dim(difSHD)[1], colnames(difSHD)]) colnames(difSHD) &lt;- c(&quot;SHD&quot;) ggplot(difSHD, aes(x=as.numeric(substring(rownames(difSHD), 2)), y=SHD)) + geom_line(group=1)+ geom_point(aes(color=SHD), size=5)+ scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, name=&quot;SHD&quot;, guide = guide_legend())+ theme_bw()+xlab(&quot;R&quot;)+ylab(&quot;structural hamming distance&quot;)+ theme(legend.position=&quot;bottom&quot;) parallel::stopCluster(cl) "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
