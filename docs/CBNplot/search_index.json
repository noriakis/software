[["index.html", "CBNplot Chapter 1 CBNplot: Bayesian network plot for enrichment analysis results 1.1 The preprocessing and DEG identification of GSE133624", " CBNplot Noriaki Sato Chapter 1 CBNplot: Bayesian network plot for enrichment analysis results The R package to plot Bayesian network inferred from expression data based on the enrichment analysis results including clusterProfiler or ReactomePA results (Wu et al. 2021; Yu and He 2016). It makes use of libraries including clusterProfiler, ReactomePA, bnlearn, graphite and depmap (Killian and Gatto 2021; Scutari 2010; Sales et al. 2012). The description of functions and several use cases are depicted in this book using GSE133624, which contains RNA-Seq data of bladder cancer and adjacent normal bladder tissues (Chen et al. 2019). 1.1 The preprocessing and DEG identification of GSE133624 In this book, the data from GSE133624 was used for the demonstrative purpose, and the parameters can be changed. First, DESeq2 is used to identify DEGs (Love, Huber, and Anders 2014). library(DESeq2) ## Load dataset and make metadata counts = read.table(&quot;GSE133624_reads-count-all-sample.txt&quot;, header=1, row.names=1) meta = sapply(colnames(counts), function (x) substring(x,1,1)) meta = data.frame(meta) colnames(meta) = c(&quot;Condition&quot;) dds &lt;- DESeqDataSetFromMatrix(countData = counts, colData = meta, design= ~ Condition) ## Prefiltering filt &lt;- rowSums(counts(dds) &lt; 10) &gt; dim(meta)[1]*0.9 dds &lt;- dds[!filt,] ## Perform DESeq2() dds = DESeq(dds) res = results(dds, pAdjustMethod = &quot;bonferroni&quot;) ## apply variance stabilizing transformation v = vst(dds, blind=FALSE) vsted = assay(v) ## Plot PCA of VST values DESeq2::plotPCA(v, intgroup=&quot;Condition&quot;)+ theme_bw() ## Define the input genes, and use clusterProfiler::bitr to convert the ID. sig = subset(res, padj&lt;0.05) cand.entrez = clusterProfiler::bitr(rownames(sig), fromType=&quot;ENSEMBL&quot;, toType=&quot;ENTREZID&quot;, OrgDb=org.Hs.eg.db)$ENTREZID ## Perform enrichment analysis (ORA) pway = ReactomePA::enrichPathway(gene = cand.entrez) pwayGO = clusterProfiler::enrichGO(cand.entrez, ont = &quot;BP&quot;, OrgDb = org.Hs.eg.db) ## Convert to SYMBOL pway = setReadable(pway, OrgDb=org.Hs.eg.db) pwayGO = setReadable(pwayGO, OrgDb=org.Hs.eg.db) ## Store the similarity pway = enrichplot::pairwise_termsim(pway) ## Define including samples incSample = rownames(subset(meta, Condition==&quot;T&quot;)) Additionally, for the gene set enrichment analysis, log2 fold changes are obtained. allEntrez = clusterProfiler::bitr(rownames(res), fromType=&quot;ENSEMBL&quot;, toType=&quot;ENTREZID&quot;, OrgDb=org.Hs.eg.db) res$ENSEMBL &lt;- rownames(res) lfc &lt;- merge(data.frame(res), allEntrez, by=&quot;ENSEMBL&quot;) lfc &lt;- lfc[order(lfc$log2FoldChange, decreasing=TRUE),] geneList &lt;- lfc$log2FoldChange names(geneList) &lt;- lfc$ENTREZID pwayGSE &lt;- ReactomePA::gsePathway(geneList) References "],["bootstrap-based-inference.html", "Chapter 2 bootstrap-based inference 2.1 bootstrap-based inference 2.2 Multiscale boostrap-based inference", " Chapter 2 bootstrap-based inference For bayesian network inference, two methods can be used. 2.1 bootstrap-based inference Original boot.strength() function from bnlearn follows parameterization of Imoto et al. (2002). Specify strType=\"normal\" which is default. Estimate the gene network \\(T\\) times from randomly sampled \\(X^*_{n} = (x^*_{1},...,x^*_{n})^T\\). Edge intensity is defined as \\((t1+t2)/T\\), and if \\(t1&gt;t2\\), edge confidence is defined as the confidence of direction of gene \\(i\\) to gene \\(j\\) is \\(t1/(t1+t2)\\), where the \\(t1\\) corresponds to the number of edges of gene \\(i\\) to \\(j\\) and \\(t2\\) the number of edges of gene \\(j\\) to \\(i\\). 2.2 Multiscale boostrap-based inference Additionally, the multiscale boostrap-based inference is implemented (Kamimura et al. 2003). Specify strType=\"ms\" for the multiscale version. The drawback is that it consumes more time. \\(n&#39;/n\\) was defined as the same parameter as the original paper. \\[n&#39;/n = (0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4)\\] For the arrays with altered numbers of multiple \\(\\tau=\\sqrt{n/n&#39;}\\), the bootstrap-based inference are performed. \\(MS_{ij}\\) is defined as \\(1-\\Phi(d_{ij}-c_{ij})\\), using the geometric quantities \\(d_{ij}\\) and \\(c_{ij}\\). Fitting \\(BP_{ij}(\\tau) = 1-\\Phi(d_{ij}/\\tau+c_{ij}\\tau)\\), we can determine the \\(MS_{ij}\\). The fitting was performed by msfit() available in pvclust. The confidence of direction was obtained by the same method as obtaining \\(MS_{ij}\\). The resulting edges were filtered by the threshold determined by the function inclusion.threshold from bnlearn. For both approaches, the superposed network possibly does not hold the cyclic assumption (Imoto et al. 2002). Additionally, if it is preferred, setting chooseDir = TRUE can select the direction of the undirected edges using the specified score by choose.direction function in bnlearn. References "],["bngeneplot.html", "Chapter 3 bngeneplot 3.1 barplot 3.2 The vanilla plot 3.3 The plot with the reference 3.4 The plot with the DepMap information 3.5 Plotting edge strengths 3.6 Plotting genes in multiple pathways", " Chapter 3 bngeneplot # Show top-30 pathways sorted by p-value in descending order. pway@result$Description[1:30] FALSE [1] &quot;Cell Cycle Checkpoints&quot; FALSE [2] &quot;Amplification of signal from the kinetochores&quot; FALSE [3] &quot;Amplification of signal from unattached kinetochores via a MAD2 inhibitory signal&quot; FALSE [4] &quot;Mitotic Prometaphase&quot; FALSE [5] &quot;Resolution of Sister Chromatid Cohesion&quot; FALSE [6] &quot;Mitotic Spindle Checkpoint&quot; FALSE [7] &quot;EML4 and NUDC in mitotic spindle formation&quot; FALSE [8] &quot;Activation of ATR in response to replication stress&quot; FALSE [9] &quot;Muscle contraction&quot; FALSE [10] &quot;DNA strand elongation&quot; FALSE [11] &quot;Mitotic Metaphase and Anaphase&quot; FALSE [12] &quot;Mitotic Anaphase&quot; FALSE [13] &quot;DNA Replication&quot; FALSE [14] &quot;RHO GTPases Activate Formins&quot; FALSE [15] &quot;Homologous DNA Pairing and Strand Exchange&quot; FALSE [16] &quot;S Phase&quot; FALSE [17] &quot;HDR through Homologous Recombination (HRR)&quot; FALSE [18] &quot;Separation of Sister Chromatids&quot; FALSE [19] &quot;Synthesis of DNA&quot; FALSE [20] &quot;Activation of the pre-replicative complex&quot; FALSE [21] &quot;Extracellular matrix organization&quot; FALSE [22] &quot;Presynaptic phase of homologous DNA pairing and strand exchange&quot; FALSE [23] &quot;Resolution of D-loop Structures through Holliday Junction Intermediates&quot; FALSE [24] &quot;Mitotic G1 phase and G1/S transition&quot; FALSE [25] &quot;M Phase&quot; FALSE [26] &quot;CDC6 association with the ORC:origin complex&quot; FALSE [27] &quot;Resolution of D-Loop Structures&quot; FALSE [28] &quot;DNA Double-Strand Break Repair&quot; FALSE [29] &quot;G1/S Transition&quot; FALSE [30] &quot;Resolution of D-loop Structures through Synthesis-Dependent Strand Annealing (SDSA)&quot; 3.1 barplot The default barplot() from clusterProfiler. barplot(pway, showCategory = 15) 3.2 The vanilla plot This function plots inferred relationship between genes in the specific pathway, with the boot-strapped strength between genes. The normal plot can be plotted by passing the results of clusterProfiler or ReactomePA, and (normalized) expression values as well as candidate samples to be included in the inference. For the pathway including many genes, parallel computing of bootstrap-based inference can be specified with cl parameter. Running bngeneplot in the default parameter. bngeneplot(results = pway, exp = vsted, pathNum = 17) Change the label for the better readability. bngeneplot(results = pway, exp = vsted, pathNum = 17, labelSize=7, shadowText=TRUE) In general, specify samples to be included. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 17) If the resulting network is messy, we can set threshold for the averaged network, which is automatically set by function threshold() from blnearn if not specified. convertSymbol converts the output to SYMBOL. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 17, R = 10, convertSymbol = TRUE, expRow = &quot;ENSEMBL&quot;, strThresh = 0.75) 3.2.1 Show the confidence of direction The value of the confidence of edge direction can be plotted by setting showDir = T. Note that the color represents the strength value. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 50, showDir = T, convertSymbol = T, expRow = &quot;ENSEMBL&quot;, strThresh = 0.7) 3.2.2 Show the hub genes Additionally, showing the hub gene (defined by hub parameter which highlights genes with top-\\(n\\) hub scores) is informative. Weighted Kleinberg’s hub centrality scores are calculated by igraph::hub_score(). bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 50, showDir = T, convertSymbol = T, expRow = &quot;ENSEMBL&quot;, hub=5, strThresh = 0.7) 3.3 The plot with the reference The relationship between genes can be compared with the reference network by the option compareRef=TRUE and specifying pathDb. By default, the intersection of two directed network is shown with the number of overlapping edges. library(parallel) cl = makeCluster(4) bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 30, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, expRow = &quot;ENSEMBL&quot;, cl = cl) We can plot the difference between the reference network by specifying compareRefType=\"difference\". bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;difference&quot;, expRow = &quot;ENSEMBL&quot;) 3.4 The plot with the DepMap information Additionally, DepMap dependency scores can be plotted as the size of nodes using depmap package by specifying sizeDep=TRUE. It is especially useful for cancer-related research. You must provide depmap::depmap_crispr() or the other data describing the dependency score to dep variable. If not, CRISPR scores are downloaded, cached and used. Additionally, the name of cell line interested must be specified. If sizeDep=T, the histogram of overall and within-pathway dependency scores will be plotted besides the network. dep = depmap::depmap_crispr() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 5,compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep) It can be the RNA interference based score. rnai = depmap::depmap_rnai() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 3, R = 5,compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = rnai, cellLineName = &quot;UMUC3_URINARY_TRACT&quot;) Additionally, we can plot the dependency scores of interested genes across the lineage by specifying showLineage=TRUE. We must provide metadata from depmap::depmap_metadata() to depMeta. depMeta = depmap::depmap_metadata() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep, showLineage = T, depMeta = depMeta) 3.5 Plotting edge strengths We can add a barplot depicting the edge strength and direction (probability), by specifying strengthPlot=TRUE and nStrength. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep, strengthPlot = T, nStrength = 10) 3.6 Plotting genes in multiple pathways cl = makeCluster(8) bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = c(15, 16), R = 10, convertSymbol = T, expRow = &quot;ENSEMBL&quot;) "],["bnpathplot.html", "Chapter 4 bnpathplot 4.1 emapplot 4.2 The vanilla plot 4.3 Compare with the reference 4.4 Reflect DepMap information to pathways 4.5 Aggregating the pathway databases", " Chapter 4 bnpathplot 4.1 emapplot The default emapplot from clusterProfiler. emapplot(pway) 4.2 The vanilla plot This function plots inferred relationship between pathways, with the boot-strapped strength between pathways. The normal plot can be plotted by bnpathplot, passing the results of clusterProfiler or ReactomePA, (normalized) expression values, and candidate rows to be included in the inference. nCategory specifies the number of categories (1:nCategory) to be plotted, sorted by the p-value. expRow indicates what identifiers are used in row names of expression matrix. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, labelSize=5, expRow = &quot;ENSEMBL&quot;) For the messy plot, the label can be modified using shadowText=TRUE. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, labelSize=3, shadowText=TRUE, expRow = &quot;ENSEMBL&quot;) It can be KEGG or GO pathway results using enrichKEGG and enrichGO. bnpathplot(results = pwayGO, exp = vsted, expSample = incSample, nCategory = 30, R = 10, expRow = &quot;ENSEMBL&quot;) Or it can be the GSEA result. bnpathplot(results = pwayGSE, exp = vsted, expSample = incSample, nCategory = 30, R = 10, expRow = &quot;ENSEMBL&quot;, shadowText = TRUE, color = &quot;enrichmentScore&quot;) 4.3 Compare with the reference For Reactome, the relationship between pathways can also be plotted by specifying compareRef=TRUE. Here, dotted lines indicate relationship not in the reference, and solid lines indicate those in the reference. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, compareRef=T, expRow = &quot;ENSEMBL&quot;) 4.4 Reflect DepMap information to pathways We can reflect overall dependency scores for the genes within the pathway by specifying sizeDep=TRUE. You must provide depmap::depmap_crispr or the other data describing the dependency score to dep variable. The average score of the genes in the pathway is used. bnpathplot(results = pwayGO, exp = vsted, expSample = incSample, nCategory = 30, R = 50, sizeDep = T, dep = dep, expRow = &quot;ENSEMBL&quot;) 4.5 Aggregating the pathway databases The multiple GSEA results can be aggregated, by just passing the multiple results like as follows. When choosing the number of categories (nCategory), the order of the results and the numbers should be same. library(DOSE) pwayDO &lt;- enrichDO(gene = cand.entrez) ReaAndDO &lt;- bnpathplot(results = c(pway, pwayDO), exp = vsted, expSample = incSample, nCategory = c(20, 20), R = 50) ReaAndDO "],["including-clinical-variables.html", "Chapter 5 Including clinical variables 5.1 Preparation of data 5.2 Inference of pathway relationship including clinical variables 5.3 Conditional probability query 5.4 Gene relationship with variables 5.5 Confirming the existing knowledge 5.6 Investigating the network based on the clinical question 5.7 Classification using BN", " Chapter 5 Including clinical variables 5.1 Preparation of data One of the important reasons of the Bayesian network analysis is assessing the relationship between gene expressions and clinical variables. CBNplot offers incorporating metadata into inference. As a demonstrative purpose, the enrichment analysis results from GSE133624 is applied on data from The Cancer Genome Atlas Program (TCGA) (Cancer Genome Atlas Research Network et al. 2013). Specifically, TCGA-BLCA data is downloaded by the useful library TCGAbiolinks (Colaprico et al. 2016). library(TCGAbiolinks) ## Not run # query &lt;- GDCquery(project = &quot;TCGA-BLCA&quot;, # data.category = &quot;Transcriptome Profiling&quot;, # data.type = &quot;Gene Expression Quantification&quot;, # workflow.type = &quot;HTSeq - Counts&quot;) # download &lt;- GDCdownload(query) # tcgaData &lt;- GDCprepare(query) # save(file=&quot;tcgaData.rda&quot;, tcgaData) ## Load dataset load(file=&quot;tcgaData.rda&quot;) We again applied VST on the data (the design is not included in this vignette), and filtered the metadata based on the variables to be included in the inference. In this analysis, age_at_diagnosis and paper_Combined T and LN category, which is a sum of Tumor category 1/2 (0) vs. 3/4 (1) and LN negative (0) vs positive (1), are included. library(DESeq2) library(dplyr) dataAssay &lt;- assays(tcgaData) tcgaCount &lt;- dataAssay@listData$`HTSeq - Counts` ## Make DESeq2 object ddsTCGA &lt;- DESeqDataSetFromMatrix(countData = tcgaCount, colData = tcgaData@colData, design= ~ 1) vstedTCGA &lt;- assay(vst(ddsTCGA, blind=FALSE)) ## Variable selection phase metadata &lt;- data.frame(tcgaData@colData) %&gt;% select(age_at_diagnosis, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) ## Scale and factorize metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) 5.2 Inference of pathway relationship including clinical variables We assess the relationship between the curated biological pathway information and clinical variables mentioned above. Variables other than expression data can be specified with otherVar, as well as otherVarName for their name. The order of otherVar must be same as column order of expression data. We use all the significant pathways of corrected p-values below 0.05. bnCov &lt;- bnpathplot(pway, vstedTCGA, nCategory = 1000, adjpCutOff = 0.05, expSample=rownames(metadata), algo=&quot;hc&quot;, strType=&quot;normal&quot;, otherVar=metadata, otherVarName=c(&quot;Age&quot;, &quot;Category&quot;), R=50, cl=parallel::makeCluster(10), returnNet=T) ## Check DAG igraph::is.dag(as.igraph(bnCov$av)) FALSE [1] TRUE ## Fit the parameter to network based on the data bnFit &lt;- bn.fit(bnCov$av, bnCov$df) Plot the resulting network. bnCov$plot 5.3 Conditional probability query Next we perform conditional probability queries by the bnlearn function cpdist to elucidate how the clinical variables affect pathway regulation. First we fit the inferred network to the original data. These are stored in the named list. Logic sampling is performed unless otherwise stated. Perform cpdist, and visualize the distribution of “Molecules associated with elastic fibres” conditional on the tumor category using ggdist. library(bnlearn) library(ggdist) library(ggplot2) candPath &lt;- &quot;Molecules associated with elastic fibres&quot; efz &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==0)) efo &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==1)) eft &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==2)) effect = data.frame( val = c(efz[,1], efo[,1], eft[,1]), stage = c(rep(&quot;0&quot;,nrow(efz)), rep(&quot;1&quot;, nrow(efo)), rep(&quot;2&quot;, nrow(eft))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(efz)), rep(stageWMean[2], nrow(efo)), rep(stageWMean[3], nrow(eft))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candPath) How the down-regulation in “Cell Cycle Checkpoints” affects the other pathways? This time using the importance sampling method, likelihood weighting. predNodes &lt;- names(bnFit) predNodes &lt;- predNodes[predNodes != &quot;Cell Cycle Checkpoints&quot;] maxVal &lt;- max(bnCov$df[candPath]) minVal &lt;- min(bnCov$df[candPath]) lowCCC &lt;- cpdist(bnFit, nodes=predNodes, evidence=list(&quot;Cell Cycle Checkpoints&quot;=minVal), method=&quot;lw&quot;) lowW &lt;- attributes(lowCCC)$weights highCCC &lt;- cpdist(bnFit, nodes=predNodes, evidence=list(&quot;Cell Cycle Checkpoints&quot;=maxVal), method=&quot;lw&quot;) highW &lt;- attributes(highCCC)$weights ## Remove the factor highCCC$Category &lt;- NULL lowCCC$Category &lt;- NULL difMeanCCC &lt;- apply(highCCC, 2, function(x) weighted.mean(x, highW)) - apply(lowCCC, 2, function(x) weighted.mean(x, lowW)) ## Top absolute value kable(head(difMeanCCC[order(abs(difMeanCCC), decreasing=TRUE)]), col.names=c(&quot;difference&quot;)) difference M Phase 23.34542 Mitotic Prometaphase 21.11944 Mitotic Metaphase and Anaphase 20.76569 Mitotic Anaphase 20.62871 RHO GTPase Effectors 19.45905 Separation of Sister Chromatids 19.40454 ## Reflect the difference in the plot modifying ggplot2 object changeCol &lt;- bnCov$plot$data difMeanCCC &lt;- difMeanCCC[changeCol$name] names(difMeanCCC) &lt;- changeCol$name changeCol$color &lt;- difMeanCCC ## Replace the color, change the legend bnCov$plot$data &lt;- changeCol bnCov$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) 5.4 Gene relationship with variables For the genes in interesting pathway, clinical variables can be incorporated too. We investigated the genes involved in the reactome “Molecules associated with elastic fibres.” bnGeneCov &lt;- bngeneplot(pway, vstedTCGA, pathNum=43, expSample=rownames(metadata), otherVar=metadata, hub=5, R=100, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) Plot the resulting network of genes. ## Plot bnGeneCov$plot ## Check DAG igraph::is.dag(as.igraph(bnGeneCov$av)) FALSE [1] TRUE ## Fit the parameter to network based on the data bnFitGene &lt;- bn.fit(bnGeneCov$av, bnGeneCov$df) Perform cpdist, and examine the mean and distribution using ggdist. We can see that the expression of the gene EFEMP1, which is reported to be a candidate for a biomarker of aggressive bladder cancer or therapeutic targets (Han et al. 2017), is going up with each stage. candGene &lt;- &quot;EFEMP1&quot; efz &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==0)) efo &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==1)) eft &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==2)) effect = data.frame( val = c(efz[,1], efo[,1], eft[,1]), stage = c(rep(&quot;0&quot;,nrow(efz)), rep(&quot;1&quot;, nrow(efo)), rep(&quot;2&quot;, nrow(eft))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(efz)), rep(stageWMean[2], nrow(efo)), rep(stageWMean[3], nrow(eft))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) 5.5 Confirming the existing knowledge To confirm the validity of the inferred Bayesian network, we can focus on some genes that is already validated to be related to clinical information or is incorporated into the daily clinical practice. To obtain the pathways that include the specific gene, one can use obtainPath function. This time we focus on the gene MMP2, as the gene has been reported to be related to clinical variables in bladder cancer (Vasala, Pääkkö, and Turpeenniemi-Hujanen 2003; Fouad et al. 2019; Winerdal et al. 2018). pathSub &lt;- obtainPath(pway, &quot;MMP2&quot;) Using the top pathway involving MMP2, construct the network and plot. bnGeneCov2 &lt;- bngeneplot(pathSub, vstedTCGA, pathNum=1, expSample=rownames(metadata), otherVar=metadata, hub=5, R=50, algo=&quot;hc&quot;, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnGeneCov2$plot bnGeneCov2$av &lt;- chooseEdgeDir(bnGeneCov2$av, bnGeneCov2$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) bnGeneCov2Fit &lt;- bn.fit(bnGeneCov2$av, bnGeneCov2$df) Predict the distribution. candGene &lt;- &quot;MMP2&quot; mz &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==0), method=&quot;ls&quot;) mo &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==1), method=&quot;ls&quot;) mt &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==2), method=&quot;ls&quot;) effect = data.frame( val = c(mz[,1], mo[,1], mt[,1]), stage = c(rep(&quot;0&quot;,nrow(mz)), rep(&quot;1&quot;, nrow(mo)), rep(&quot;2&quot;, nrow(mt))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(mz)), rep(stageWMean[2], nrow(mo)), rep(stageWMean[3], nrow(mt))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) It is interesting to investigate whether the result is similar in the other database, like Gene Ontology doing the same analysis. ## Perform the same analysis on GO enrichment result pathSubGO &lt;- obtainPath(pwayGO, &quot;MMP2&quot;) pathSubGO@result[1:3, c(&quot;Description&quot;,&quot;geneID&quot;)] FALSE Description FALSE GO:0045229 external encapsulating structure organization FALSE GO:0030198 extracellular matrix organization FALSE GO:0043062 extracellular structure organization FALSE geneID FALSE GO:0045229 DCN/IBSP/TIMP2/ELN/LAMC3/LAMC2/COL11A1/NFKB2/FBLN1/ITGA8/COL4A4/COL19A1/COL16A1/MMP2/CCDC80/CMA1/TGM1/ABL1/MMP11/CTSG/FERMT1/SMPD3/CRISPLD2/FOXF1/HAS1/CAV1/VWF/ADTRP/SMOC2/COL7A1/CCN2/FMOD/SERAC1/RECK/MMP19/LRP1/COL10A1/MMP24/RAMP2/MYH11/PDGFRA/ADAMTS8/ITGA7/IL6/CTSV/MMP27/MMP13/THBS1/ADAM10/EMILIN1/FGF2/FBN2/FBLN5/COL6A1/COL6A2/HSPG2/CCN1/DPT/ITGA9/SFRP2/CSGALNACT1/JAM2/ADAMTS1/ADAMTS5/ADAMTSL3/ITGAD/CREB3L1/ADAMTS4/SCUBE1/FGFR4/ITGA5/NTNG1/DDR2/FBLN2/PTX3/JAM3/MFAP4/MMP10/LTBP3/TNXB/CRTAP/ANGPTL7/LAMB2/TPSAB1/EFEMP2/HPSE2/ADAMTS20/NDNF/A2M/GAS6/OLFML2A/THSD4/COL14A1/MMP23B/LAMA2/MMP1/NF1/COL13A1/ELANE/MFAP5/ERO1A/VIT/ITGA1/MARCOL FALSE GO:0030198 DCN/IBSP/TIMP2/ELN/LAMC3/LAMC2/COL11A1/NFKB2/FBLN1/ITGA8/COL4A4/COL19A1/COL16A1/MMP2/CCDC80/CMA1/ABL1/MMP11/CTSG/FERMT1/SMPD3/CRISPLD2/FOXF1/HAS1/CAV1/VWF/ADTRP/SMOC2/COL7A1/CCN2/FMOD/SERAC1/RECK/MMP19/LRP1/COL10A1/MMP24/RAMP2/MYH11/PDGFRA/ADAMTS8/ITGA7/IL6/CTSV/MMP27/MMP13/THBS1/ADAM10/EMILIN1/FGF2/FBN2/FBLN5/COL6A1/COL6A2/HSPG2/CCN1/DPT/ITGA9/SFRP2/CSGALNACT1/JAM2/ADAMTS1/ADAMTS5/ADAMTSL3/ITGAD/CREB3L1/ADAMTS4/SCUBE1/FGFR4/ITGA5/NTNG1/DDR2/FBLN2/PTX3/JAM3/MFAP4/MMP10/LTBP3/TNXB/CRTAP/ANGPTL7/LAMB2/TPSAB1/EFEMP2/HPSE2/ADAMTS20/NDNF/A2M/GAS6/OLFML2A/THSD4/COL14A1/MMP23B/LAMA2/MMP1/NF1/COL13A1/ELANE/MFAP5/ERO1A/VIT/ITGA1/MARCOL FALSE GO:0043062 DCN/IBSP/TIMP2/ELN/LAMC3/LAMC2/COL11A1/NFKB2/FBLN1/ITGA8/COL4A4/COL19A1/COL16A1/MMP2/CCDC80/CMA1/ABL1/MMP11/CTSG/FERMT1/SMPD3/CRISPLD2/FOXF1/HAS1/CAV1/VWF/ADTRP/SMOC2/COL7A1/CCN2/FMOD/SERAC1/RECK/MMP19/LRP1/COL10A1/MMP24/RAMP2/MYH11/PDGFRA/ADAMTS8/ITGA7/IL6/CTSV/MMP27/MMP13/THBS1/ADAM10/EMILIN1/FGF2/FBN2/FBLN5/COL6A1/COL6A2/HSPG2/CCN1/DPT/ITGA9/SFRP2/CSGALNACT1/JAM2/ADAMTS1/ADAMTS5/ADAMTSL3/ITGAD/CREB3L1/ADAMTS4/SCUBE1/FGFR4/ITGA5/NTNG1/DDR2/FBLN2/PTX3/JAM3/MFAP4/MMP10/LTBP3/TNXB/CRTAP/ANGPTL7/LAMB2/TPSAB1/EFEMP2/HPSE2/ADAMTS20/NDNF/A2M/GAS6/OLFML2A/THSD4/COL14A1/MMP23B/LAMA2/MMP1/NF1/COL13A1/ELANE/MFAP5/ERO1A/VIT/ITGA1/MARCOL bnCovGO &lt;- bngeneplot(pathSubGO, vstedTCGA, pathNum=1, algo=&quot;hc&quot;, expSample=rownames(metadata), otherVar=metadata, R=100, layout=&quot;sugiyama&quot;, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnCovGO$av &lt;- chooseEdgeDir(bnCovGO$av, bnCovGO$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) bnCovGO$av$nodes$Category FALSE $mb FALSE [1] &quot;COL6A1&quot; FALSE FALSE $nbr FALSE [1] &quot;COL6A1&quot; FALSE FALSE $parents FALSE character(0) FALSE FALSE $children FALSE [1] &quot;COL6A1&quot; bnGeneCovGOFit &lt;- bn.fit(bnCovGO$av, bnCovGO$df) mz &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==0), method=&quot;ls&quot;) mo &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==1), method=&quot;ls&quot;) mt &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==2), method=&quot;ls&quot;) effect = data.frame( val = c(mz[,1], mo[,1], mt[,1]), stage = c(rep(&quot;0&quot;,nrow(mz)), rep(&quot;1&quot;, nrow(mo)), rep(&quot;2&quot;, nrow(mt))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(mz)), rep(stageWMean[2], nrow(mo)), rep(stageWMean[3], nrow(mt))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) + labs(caption=pathSubGO@result$Description[1]) 5.6 Investigating the network based on the clinical question After confirming the knowledge, it is interesting to test how difference in clinical variables affect gene expression. bnlearn can naturally handle this again using cpdist. We now include two more variables, age_at_diagnosis, gender, paper_Noninvasive.bladder.cancer.therapy, paper_Combined.T.and.LN.category. Inference based on these information, we can ask: Which genes have the biggest expression differences between those treated with BCG and with none, considering the networks of genes and clinical variables of age, gender, tumor category in TCGA-BLCA dataset using genes significantly differed in GSE133624 and involved in curated biological pathways related to MMP2? ## Metadata filtering metadata &lt;- data.frame(tcgaData@colData) %&gt;% select(age_at_diagnosis, gender, paper_Noninvasive.bladder.cancer.therapy, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) %&gt;% filter(paper_Noninvasive.bladder.cancer.therapy!=&quot;ND&quot;) metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$gender &lt;- as.factor(metadata$gender) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) metadata$paper_Noninvasive.bladder.cancer.therapy &lt;- as.factor(metadata$paper_Noninvasive.bladder.cancer.therapy) ## Subset to significant pathways, and those related to MMP2 pway@result &lt;- subset(pway@result, p.adjust&lt;0.05) pathSub &lt;- obtainPath(pway, &quot;MMP2&quot;) bnCovGene3 &lt;- bngeneplot(pathSub, vstedTCGA, pathNum = seq_len(nrow(pathSub)), expSample=rownames(metadata), otherVar=metadata, hub=5, R=50, otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;Therapy&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnCovGene3$av &lt;- chooseEdgeDir(bnCovGene3$av, bnCovGene3$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) bnCovGene3Fit &lt;- bn.fit(bnCovGene3$av, bnCovGene3$df) allGenes &lt;- names(bnCovGene3$av$nodes) allGenes &lt;- allGenes[!allGenes %in% c(&quot;Age&quot;,&quot;Gender&quot;,&quot;Therapy&quot;,&quot;Category&quot;)] no &lt;- cpdist(bnCovGene3Fit, nodes=allGenes, evidence=(Therapy==&quot;none&quot;), method=&quot;ls&quot;) bcg &lt;- cpdist(bnCovGene3Fit, nodes=allGenes, evidence=(Therapy==&quot;Bacillus Calmette.Guerin (BCG)&quot;), method=&quot;ls&quot;) difMean &lt;- data.frame(apply(bcg, 2, mean)-apply(no, 2, mean)) difMean$name &lt;- rownames(difMean) colnames(difMean) &lt;- c(&quot;difference&quot;,&quot;name&quot;) difMean &lt;- difMean[order(abs(difMean$difference), decreasing=T),] kable(head(difMean, n=5)) difference name IBSP 0.3155639 IBSP PCOLCE 0.3116941 PCOLCE COL25A1 0.2480732 COL25A1 MMP10 -0.1240790 MMP10 ADAMTS4 0.1054224 ADAMTS4 We can reflect the difference to the plot. In the previous EFEMP1 plot: candGene &lt;- names(bnFitGene) candGene &lt;- candGene[candGene != &quot;Category&quot;] efz2 &lt;- cpdist(bnFitGene, nodes=candGene, evidence=(Category==0)) eft2 &lt;- cpdist(bnFitGene, nodes=candGene, evidence=(Category==2)) difMean &lt;- apply(eft2, 2, mean) - apply(efz2, 2, mean) changeCol &lt;- bnGeneCov$plot$data difMean &lt;- difMean[changeCol$name] names(difMean) &lt;- changeCol$name changeCol$color &lt;- difMean ## Replace shape and color changeCol$shape &lt;- rep(19, dim(bnGeneCov$plot$data)[1]) bnGeneCov$plot$data &lt;- changeCol bnGeneCov$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) 5.7 Classification using BN Inferred BN can be used as a classifier of conditions. In this analysis, we perform the classification of whether the cancer samples are harboring TP53 mutation or not (column paper_mutation in TP53). First, we make a metadata table as same as the above examples. metadata &lt;- data.frame(tcgaData@colData) %&gt;% dplyr::select(age_at_diagnosis, gender, paper_mutation.in.TP53, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_mutation.in.TP53!=&quot;ND&quot;) %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) table(metadata$paper_mutation.in.TP53) FALSE FALSE no yes FALSE 184 163 ## Set TP53 status to numeric of 0/1. metadata$paper_mutation.in.TP53 &lt;- as.numeric(as.factor(metadata$paper_mutation.in.TP53))-1 metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) metadata$gender &lt;- as.factor(metadata$gender) Split the data to train/test according to TP53 mutation status using caret (Kuhn 2008). In this analysis, the five-fold cross validation (stratified) is performed. Fit the model using the expression of genes in the pathway. This time the classification performance of significant pathways (corrected p &lt; 1e-5) are to be compared. onlyDf option can be enabled to return only the data.frame containing data for prediction, useful for testing purpose, and using the resulting data for the other softwares. set.seed(53) # Seed for split trainIndex &lt;- caret::createFolds(factor(metadata$paper_mutation.in.TP53), k = 5, list = TRUE, returnTrain=TRUE) allnets &lt;- list() ## Store network in the list allClassRes &lt;- list() ## Store prediction in the list ## Already VSTed DF load(&quot;trainDf.rda&quot;) load(&quot;testDf.rda&quot;) for (f in seq_len(5)) { nets &lt;- list() classRes &lt;- list() foldTrainIndex &lt;- trainIndex[[f]] ## Recursively fit and test for significant pathways for (pnum in seq(1, dim(subset(pway@result, p.adjust&lt;1e-5))[1], 1)) { cl &lt;- parallel::makeCluster(12) bnCovTrain &lt;- bngeneplot(pway, assay(trainDf[[f]]), pathNum=pnum, layout=&quot;sugiyama&quot;, expSample=rownames(metadata[foldTrainIndex,]), algo=&quot;hc&quot;, strType=&quot;normal&quot;, otherVar=metadata[foldTrainIndex,], otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;TP53&quot;,&quot;Category&quot;), R=50, cl=cl, returnNet=T) ## Return only DF for testing bnCovTest &lt;- bngeneplot(pway, assay(testDf[[f]]), pathNum=pnum, expSample=rownames(metadata[-foldTrainIndex,]), otherVar=metadata[-foldTrainIndex,], otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;TP53&quot;,&quot;Category&quot;), onlyDf=T) bnCovTrain$av &lt;- chooseEdgeDir(bnCovTrain$av, bnCovTrain$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) ## If DAG and TP53 have parents if ( igraph::is.dag(bnlearn::as.igraph(bnCovTrain$av)) &amp;&amp; length(bnCovTrain$av$nodes$TP53$parents) &gt;= 1 ){ bnCovLargeFit &lt;- bnlearn::bn.fit(bnCovTrain$av, bnCovTrain$df) pred &lt;- sigmoid::sigmoid(predict(bnCovLargeFit, node=&quot;TP53&quot;, data=bnCovTest, method = &quot;bayes-lw&quot;)) # Use sigmoid function classRes[[pway@result$Description[pnum]]] &lt;- pred nets[[pway@result$Description[pnum]]] &lt;- bnCovTrain } else { message(paste0(&quot;Among pathway &quot;, pway@result$Description[pnum], &quot;, no parent node of TP53 is found, or inferred network is not dag.&quot;)) } parallel::stopCluster(cl) } allnets[[f]] &lt;- nets allClassRes[[f]] &lt;- classRes } Using the library pROC, calculate the area under ROC (auROC) (Robin et al. 2011). library(pROC) library(ggplotify) rocDf &lt;- c() allRocList &lt;- list() for (f in seq_len(5)) { correct &lt;- metadata[-trainIndex[[f]],]$paper_mutation.in.TP53 predDf &lt;- data.frame(allClassRes[[f]]) predDf$label &lt;- correct rocList &lt;- list() for (i in seq_len(dim(predDf)[2]-1)){ rocList[[names(predDf)[i]]] &lt;- roc(predDf$label, predDf[,i], ci=TRUE, direction=&quot;&lt;&quot;) # check direction } tmpRocDf &lt;- data.frame(t(data.frame(purrr::map(rocList, function(x) as.numeric(x$auc))))) colnames(tmpRocDf) &lt;- c(paste0(&quot;auc&quot;,f)) tmpRocDf$name &lt;- rownames(tmpRocDf) allRocList[[f]] &lt;- tmpRocDf } allRocListDf &lt;- allRocList %&gt;% purrr::reduce(left_join, by = &quot;name&quot;) rocMean &lt;- allRocListDf %&gt;% rowwise() %&gt;% mutate(Min = min(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Max = max(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Mean = mean(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Sd = sd(c_across(starts_with(&quot;auc&quot;)), na.rm=T)) %&gt;% select(name ,Mean, Sd) %&gt;% arrange(desc(Mean)) kable(rocMean, row.names=FALSE, booktab=TRUE) %&gt;% kable_styling(font_size = 10) name Mean Sd Synthesis.of.DNA 0.7617083 0.0197920 DNA.strand.elongation 0.7610867 0.0447672 S.Phase 0.7477910 0.0604088 DNA.Replication 0.7454379 0.0267092 Mitotic.Anaphase 0.7380699 0.0904557 Homologous.DNA.Pairing.and.Strand.Exchange 0.7372571 0.0425876 Amplification.of.signal.from.the.kinetochores 0.7326969 0.0336989 Activation.of.ATR.in.response.to.replication.stress 0.7315833 0.0304301 HDR.through.Homologous.Recombination..HRR. 0.7257252 0.0375426 Resolution.of.Sister.Chromatid.Cohesion 0.7244716 0.0379770 Mitotic.Spindle.Checkpoint 0.7125529 0.0983849 EML4.and.NUDC.in.mitotic.spindle.formation 0.7114205 0.0610378 RHO.GTPases.Activate.Formins 0.7082628 0.0509439 Amplification..of.signal.from.unattached..kinetochores.via.a.MAD2..inhibitory.signal 0.7051580 0.0971843 Mitotic.Prometaphase 0.6920722 0.1130915 Mitotic.Metaphase.and.Anaphase 0.6852534 0.0919988 Cell.Cycle.Checkpoints 0.6845920 0.0785945 Separation.of.Sister.Chromatids 0.6668151 0.0758921 Show the resulting network with the top auROC, and the ROC plot using pROC (Robin et al. 2011). topPath &lt;- rocMean[1,&quot;name&quot;] candFold &lt;- as.numeric(allRocListDf %&gt;% filter(name == as.character(topPath)) %&gt;% summarize(which.max(c_across(starts_with(&quot;auc&quot;))))) ## With the CI candRoc &lt;- data.frame(metadata[-trainIndex[[candFold]],]$paper_mutation.in.TP53) colnames(candRoc) &lt;- c(&quot;label&quot;) candRoc$pred &lt;- as.numeric(unlist(allClassRes[[candFold]][gsub(&quot;[.]&quot;, &quot; &quot;, as.character(topPath))])) rocplot &lt;- as.ggplot(function(){ rocobj1 &lt;- plot.roc(candRoc$label, candRoc$pred, print.auc = TRUE, ci=TRUE, col=&quot;black&quot;, direction=&quot;&lt;&quot;, main = &quot;Mutation in TP53&quot;, percent=TRUE) ciobj &lt;- ci.se(rocobj1, specificities = seq(0, 100, 5), progress=&quot;none&quot;) plot(ciobj, type = &quot;shape&quot;, col = &quot;steelblue&quot;) }) ## Along with the network topNet &lt;- allnets[[candFold]][[gsub(&quot;[.]&quot;, &quot; &quot;, topPath)]] topNet$plot + rocplot Using bnlearn::cpdist, check the difference in the distribution mean when the value of the node TP53 is above and below 0.5. topFit &lt;- bnlearn::bn.fit(topNet$av, topNet$df) candNodes &lt;- names(topNet$av$nodes) candNodes &lt;- candNodes[!candNodes %in% c(&quot;TP53&quot;,&quot;Category&quot;,&quot;Gender&quot;)] tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &lt; 0.5)) dim(tp53low) FALSE [1] 5238 43 tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &gt; 0.5)) dim(tp53high) FALSE [1] 4838 43 difMeanTp53 &lt;- apply(tp53high, 2, mean) - apply(tp53low, 2, mean) kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM8 0.4148223 GINS1 0.3657697 CCNE2 0.3321690 MCM2 0.3014382 CCNA2 0.2790458 PRIM2 0.2650689 changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) When the TP53 takes the extreme values on logic sampling. topFit &lt;- bnlearn::bn.fit(topNet$av, topNet$df) candNodes &lt;- names(topNet$av$nodes) candNodes &lt;- candNodes[!candNodes %in% c(&quot;TP53&quot;,&quot;Category&quot;,&quot;Gender&quot;)] tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &lt; 0.01)) dim(tp53low) FALSE [1] 1817 43 tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &gt; 0.99)) dim(tp53high) FALSE [1] 1544 43 difMeanTp53 &lt;- apply(tp53high, 2, mean) - apply(tp53low, 2, mean) kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM8 0.8367092 GINS1 0.7907773 MCM2 0.6893688 CCNE2 0.6853833 CCNA2 0.5952305 UBE2C 0.5876228 changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) Perform likelihood weighting. tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=list(TP53 = 0), method=&quot;lw&quot;) tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=list(TP53 = 1), method=&quot;lw&quot;) difMeanTp53 &lt;- apply(tp53high, 2, function(x) weighted.mean(x, attributes(tp53high)$weights)) - apply(tp53low, 2, function(x) weighted.mean(x, attributes(tp53low)$weights)) changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM8 0.5182777 GINS1 0.4672844 MCM2 0.3971931 CCNE2 0.3963333 CCNA2 0.3653391 PRIM2 0.3513318 names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) queryCpDistLw function performs sampling by likelihood weighting using cpdist, and returns the data.frame with weights. It just performs cpdist on the queried level and produce a plot. queryCpDistLs performs logic sampling. ## Only likelihood weighting is supported in queryCpDist. q1 &lt;- queryCpDistLw(topFit, names(difMeanTp53)[1], evidence=&quot;TP53&quot;, level=c(0,0.5,1)) kable(head(q1$df[,c(names(difMeanTp53)[1],&quot;weights&quot;)])) RFC2 weights 10.18251 0.7617622 10.89386 0.8735042 10.86273 0.2503467 10.68833 0.8270155 11.01903 0.7779707 10.79366 0.9128175 References "],["the-other-options.html", "Chapter 6 The other options 6.1 Discretization 6.2 Custom visualization 6.3 Comparing multi scale and standard bootstrapping", " Chapter 6 The other options 6.1 Discretization If passed an option disc=TRUE, the continuous variables are discretized using arules::discretize function (Hahsler et al. 2011). The discretization of the gene expression data is discussed in Gallo et al. (2016). If the same discretization is to be applied on the other data like the training and test dataset, you can pass the training samples to tr option, and if some variables are not intended to be discretized, you should pass the column name to remainCont. bngeneplot(results = pway, exp = vsted, pathNum = 1, disc=TRUE, layout=&quot;sugiyama&quot;) 6.2 Custom visualization 6.2.1 The glowing nodes and edges In addition to the normal plot, custom function of visualization is implemented (bngeneplotCustom and bnpathplotCustom). For example, to effectively visualize the hub genes and edges with high strength by glowing the respective nodes and edges, below is an example using an idea of ggCyberPunk. Additionally, the edge and node colors are fully customizable. cl = parallel::makeCluster(6) bngeneplotCustom(results = pway, exp = vsted, expSample = incSample, R=50, cl=cl, layout=&quot;nicely&quot;, fontFamily=&quot;sans&quot;, pathNum = c(23), strType=&quot;normal&quot;, sizeDep=T, dep=dep, showDir=FALSE, hub=5, glowEdgeNum=5, strThresh=0.6, strengthPlot = T) For the demonstrative purpose, using the palettes and fonts of vapoRwave and showtext, the other visualizations are possible. Note that in custom visualization, only the network plot and strength barplot are supported. ## Use alien encounter fonts (http://www.hipsthetic.com/alien-encounters-free-80s-font-family/) sysfonts::font_add(family=&quot;alien&quot;,regular=&quot;SFAlienEncounters.ttf&quot;) showtext::showtext_auto() cl = parallel::makeCluster(6) bngeneplotCustom(results = pway, exp = vsted, expSample = incSample, R=20, cl=cl, fontFamily=&quot;alien&quot;, labelSize=6, pathNum = c(15), strType=&quot;normal&quot;, showDir=F, hub=5, glowEdgeNum=5, strThresh=0.6, strengthPlot = T, sizeDep=F, dep=dep, layout=&quot;kk&quot;, edgePal=c(&quot;#9239F6&quot;,&quot;#FF4373&quot;), nodePal=c(&quot;#F8B660&quot;,&quot;#FF0076&quot;), barLegendKeyCol=&quot;#0F0D1A&quot;, textCol=&quot;#EE9537&quot;, titleCol=&quot;#EE9537&quot;, backCol=&quot;#0F0D1A&quot;, barAxisCol=&quot;#EE9537&quot;, barTextCol=&quot;#EE9537&quot;, barPal=c(&quot;#9239F6&quot;, &quot;#FF4373&quot;), barPanelGridCol=&quot;#FFB967&quot;, barBackCol=&quot;#0F0D1A&quot;, titleSize=14 ) parallel::stopCluster(cl) 6.3 Comparing multi scale and standard bootstrapping cl &lt;- parallel::makeCluster(6) comparePlot &lt;- bngeneplot(results = pway, exp = vsted, cl=cl, strType=&quot;normal&quot;, pathNum = 15, R = 50, returnNet=T, shadowText = TRUE) comparePlotMS &lt;- bngeneplot(results = pway, exp = vsted, cl=cl, strType=&quot;ms&quot;, pathNum = 15, R = 50, returnNet=T, shadowText = TRUE) kable(comparePlot$str %&gt;% filter(direction&gt;0.5) %&gt;% arrange(desc(strength)) %&gt;% head()) from to strength direction RFC5 XRCC3 0.9629630 0.6643519 RAD51AP1 BRCA1 0.9444444 0.5196759 ATR RFC2 0.9074074 0.5274471 TOPBP1 ATR 0.8703704 0.8002646 CHEK1 RAD51 0.8518519 0.7706680 DNA2 EXO1 0.8333333 0.5085979 kable(comparePlotMS$str %&gt;% filter(direction&gt;0.5) %&gt;% arrange(desc(strength)) %&gt;% head()) from to strength direction RFC2 ATR 0.9929483 0.8432828 RFC5 XRCC3 0.9873394 0.5728260 BRCA2 XRCC2 0.9824316 0.5554432 DNA2 BLM 0.9802419 0.6204331 TOPBP1 ATR 0.9763069 0.9672160 CHEK1 RAD51 0.9753282 0.7071354 References "],["testing-the-score-inside-the-pathway.html", "Chapter 7 Testing the score inside the pathway", " Chapter 7 Testing the score inside the pathway Test whether the dependency scores of genes within the pathway is different from overall score distribution (depKStest). The type variable can be either cell_line or lineage. pway &lt;- depKStest(results = pway, type = &quot;cell_line&quot;, cellLineName = &quot;253J_URINARY_TRACT&quot;, adjMethod = &quot;bonferroni&quot;, dep = dep, depMeta = depMeta) ggplot(pway@result, aes(x=depAdjP)) + geom_histogram(aes(fill=..count..), col=&quot;black&quot;) + scale_fill_gradient(&quot;Count&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + theme_minimal(base_family = &quot;Arial Narrow&quot;) + ggtitle(&quot;253J_URINARY_TRACT&quot;)+ xlab(&quot;Adjusted p-value&quot;)+ theme(plot.title = element_text(hjust=0.5, face=&quot;bold&quot;), axis.text = element_text(size=10), axis.title = element_text(size=12)) Reflect information in the plot. bnpathplot(results = pway, exp = vsted, expSample = incSample, color = &quot;depAdjP&quot;, nCategory = 30, R = 10, labelSize=5, expRow = &quot;ENSEMBL&quot;) "],["comparing-networks.html", "Chapter 8 Comparing networks 8.1 Comparing multiple networks 8.2 Testing R", " Chapter 8 Comparing networks 8.1 Comparing multiple networks The inference including hundreds of genes should be interpreted with caution especially for the low bootstrap number. For assessing the network stability, the users can compare and output F-measure by the function compareBNs, which accepts the list of multiple networks (bn) and output the pairwise F-measures. In this analysis, We perform the inference five times for 100 and 500 bootstrap numbers in the specific reactome. fvres &lt;- c() cl &lt;- parallel::makeCluster(12) for (R in c(200,500)){ n1 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n2 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n3 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n4 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) n5 &lt;- bngeneplot(pway, vstedTCGA, pathNum=13, returnNet=T, R=R, cl=cl) geneNum &lt;- length(n1$av$nodes) nets &lt;- list(n1$av, n2$av, n3$av, n4$av, n5$av) igList &lt;- list(as.igraph(n1$av), as.igraph(n2$av), as.igraph(n3$av), as.igraph(n4$av), as.igraph(n5$av)) allnets &lt;- nets fvalues &lt;- compareBNs(nets) fvres &lt;- rbind(fvres, c(&quot;TCGA&quot;, 13, geneNum, R, &quot;default&quot;, mean(fvalues), sd(fvalues))) ## Threshold 0.8 n1av &lt;- averaged.network(n1$str, threshold=0.8) n2av &lt;- averaged.network(n2$str, threshold=0.8) n3av &lt;- averaged.network(n3$str, threshold=0.8) n4av &lt;- averaged.network(n4$str, threshold=0.8) n5av &lt;- averaged.network(n5$str, threshold=0.8) nets &lt;- list(n1av, n2av, n3av, n4av, n5av) fvalues &lt;- compareBNs(nets) fvres &lt;- rbind(fvres, c(&quot;TCGA&quot;, 13, geneNum, R, 0.8, mean(fvalues), sd(fvalues))) } resDF &lt;- data.frame(fvres) colnames(resDF) &lt;- c(&quot;dataset&quot;,&quot;path_number&quot;,&quot;gene_number&quot;,&quot;R&quot;,&quot;threshold&quot;,&quot;mean&quot;,&quot;sd&quot;) pathway_name &lt;- sapply(resDF$path_number, function(x) pway@result$Description[as.numeric(x)]) resDF$label &lt;- paste0(resDF$gene_number, &quot;\\n(&quot;, stringr::str_wrap(pathway_name,10),&quot;)&quot;) kable(resDF) dataset path_number gene_number R threshold mean sd label TCGA 13 46 200 default 0.853403795842686 0.0251470800061369 46 (DNA Replication) TCGA 13 46 200 0.8 0.916561280908391 0.0226807737686349 46 (DNA Replication) TCGA 13 46 500 default 0.908741158927365 0.00848137615741657 46 (DNA Replication) TCGA 13 46 500 0.8 0.950468055786369 0.0110066613604452 46 (DNA Replication) Plot the result for the visual assessment. defa &lt;- resDF %&gt;% filter(threshold==&quot;default&quot;) %&gt;% ggplot(aes(x=label, y=as.numeric(mean), group=dataset, color=dataset, bg.color=dataset, segment.color=dataset) )+ geom_jitter(size=4, width=0.1) + theme_minimal() + geom_text_repel(aes(label = R), color = &quot;white&quot;, size=4, bg.r = .15) + scale_color_brewer(palette = &quot;Set1&quot;, name = &quot;Dataset&quot;, # The same color scall will apply to both of these aesthetics. aesthetics = c(&quot;color&quot;,&quot;bg.color&quot;,&quot;segment.color&quot;))+ geom_hline(yintercept=0.8, lty=3, color=&quot;red&quot;, size=1) + xlab(&quot;Gene number&quot;) + ylab(&quot;F-measure&quot;) + ggtitle(&quot;Default strength threshold&quot;) high &lt;- resDF %&gt;% filter(threshold==&quot;0.8&quot;) %&gt;% ggplot(aes(x=label, y=as.numeric(mean), group=dataset, color=dataset, bg.color=dataset, segment.color=dataset) )+ geom_jitter(size=4, width=0.1) + theme_minimal() + geom_text_repel(aes(label = R), color = &quot;white&quot;, size=4, bg.r = .15) + scale_color_brewer(palette = &quot;Set1&quot;, name = &quot;Dataset&quot;, # The same color scall will apply to both of these aesthetics. aesthetics = c(&quot;color&quot;,&quot;bg.color&quot;,&quot;segment.color&quot;))+ geom_hline(yintercept=0.8, lty=3, color=&quot;red&quot;, size=1) + xlab(&quot;Gene number&quot;) + ylab(&quot;F-measure&quot;) + ggtitle(&quot;Strength threshold = 0.8&quot;) defa / high Take the intersection of networks. as.bn(Reduce(igraph::intersection, igList)) FALSE FALSE Random/Generated Bayesian network FALSE FALSE model: FALSE [ORC2][GINS2][CDT1|GINS2][GINS3|GINS2][RFC2|CDT1][CDC45|GINS2:CDT1] FALSE [ORC1|CDC45:CDT1][PSMD4|RFC2][MCM7|RFC2:CDT1][UBE2C|CDC45:CDT1] FALSE [MCM10|CDC45:UBE2C][E2F1|CDC45:CDT1:UBE2C][POLD2|RFC2:ORC1:CDC45] FALSE [MCM8|ORC1:PSMD4:CDT1:UBE2C][ORC6|RFC2:CDC45:E2F1:GINS2:UBE2C] FALSE [CDC6|MCM10:ORC1:CDC45:UBE2C][GINS1|MCM10:UBE2C][MCM4|ORC1:POLD2] FALSE [PCNA|RFC2:MCM8][RFC3|ORC1:MCM8][CCNA2|MCM10:ORC1:UBE2C] FALSE [MCM2|ORC1:GINS2:PCNA][CCNE1|CDC6:PSMD4:UBE2C][UBE2S|GINS1:MCM7:UBE2C] FALSE [ANAPC1|ORC1:MCM4:MCM8:CCNA2][RFC4|MCM4:PSMD4] FALSE [DBF4|RFC2:CCNE1:ORC2:GINS2:CCNA2][PSMB5|RFC2:POLD2:UBE2S][ORC4|ORC2:ANAPC1] FALSE [PRIM1|MCM2:MCM8:PCNA][PSMA7|PSMB5:UBE2S:CCNA2:UBE2C] FALSE [POLE2|RFC2:GINS1:PSMA7:POLD2:UBE2S] FALSE [PSMA2|DBF4:MCM2:PSMA7:POLD2:ORC4:ANAPC1:UBE2C][PSMD14|ORC1:PSMB5:PSMA7:ORC4] FALSE [DNA2|DBF4:MCM10:CDC6:PSMA7:POLD2:MCM8][SKP2|GINS1:PSMA7:CCNE1] FALSE [PSMA6|POLE2:PSMB5:PSMA7:E2F1:MCM4:UBE2S:PSMD14:GINS2:CCNA2:ANAPC1:PSMD4:PRIM1] FALSE [GINS4|MCM10:ORC1:PSMA2] FALSE [CCNE2|POLE2:PSMA7:E2F1:MCM4:MCM8:GINS2:PCNA:DNA2:CCNA2] FALSE [POLE|E2F1:PCNA:DNA2:PSMD4:MCM7] FALSE [LIG1|CDC6:PSMB5:MCM4:UBE2S:ORC2:MCM8:PSMD4:CCNE2:POLE:PRIM1] FALSE [E2F3|MCM2:ORC6:PSMB5:CCNE1:UBE2S:ORC4:GINS2:PSMD4:MCM7:CCNE2] FALSE [RFC5|ORC6:CDC6:LIG1:POLE:PRIM1][PRIM2|PSMA6:E2F3:SKP2:RFC4:PRIM1] FALSE [ORC5|DBF4:RFC2:E2F1:E2F3:ANAPC1:POLE][FEN1|ORC1:E2F1:LIG1:GINS2] FALSE nodes: 46 FALSE arcs: 170 FALSE undirected arcs: 0 FALSE directed arcs: 170 FALSE average markov blanket size: 17.43 FALSE average neighbourhood size: 7.39 FALSE average branching factor: 3.70 FALSE FALSE generation algorithm: Empty 8.2 Testing R We provide the diagnostic function of inferred network across multiple bootstrap numbers. We can test how R values affect the resulting network. It is very time consuming to test many genes, thus the setting up cl argument using library parallel is suggested. We can specify which scoring function to use by scoreType. Additionally, returned strength data frame as well as raw data frame can be used to assess various metrics and thresholds like structural hamming distance. cl &lt;- parallel::makeCluster(6) pathTest &lt;- bnpathtest(results = pway, algo=&quot;hc&quot;, exp = vsted, Rrange = seq(10, 300, 10), nCategory = 15, expSample = incSample, expRow = &quot;ENSEMBL&quot;, cl = cl) # Plot difEdges &lt;- sapply(pathTest$graph, function(x) sapply(pathTest$graph, function(y) length(E(difference(as.igraph(x), as.igraph(y)))))) difEdges &lt;- data.frame(difEdges[dim(difEdges)[1], colnames(difEdges)]) colnames(difEdges) &lt;- c(&quot;NumDif&quot;) ggplot(difEdges, aes(x=as.numeric(substring(rownames(difEdges), 2)), y=NumDif)) + geom_line(group=1)+ geom_point(aes(color=NumDif), size=5)+ scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, name=&quot;Number of different edges&quot;, guide = guide_legend())+ theme_bw()+xlab(&quot;R&quot;)+ylab(&quot;Number of different edges&quot;)+ theme(legend.position=&quot;bottom&quot;) parallel::stopCluster(cl) ## Which pathway? paste(pway@result[15,]$Description, pway@result[15,]$Count) FALSE [1] &quot;Homologous DNA Pairing and Strand Exchange 22&quot; ## From 10 to 200 cl = makeCluster(6) geneTest &lt;- bngenetest(results = pway, algo=&quot;hc&quot;, pathNum=15, exp = vsted, Rrange=seq(10, 200, 10), expSample = incSample, expRow = &quot;ENSEMBL&quot;, cl = cl) difSHD &lt;- sapply(geneTest$graph, function(x) sapply(geneTest$graph, function(y) shd(x, y))) # Plot SHD compared to the highest R network difSHD &lt;- data.frame(difSHD[dim(difSHD)[1], colnames(difSHD)]) colnames(difSHD) &lt;- c(&quot;SHD&quot;) ggplot(difSHD, aes(x=as.numeric(substring(rownames(difSHD), 2)), y=SHD)) + geom_line(group=1)+ geom_point(aes(color=SHD), size=5)+ scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, name=&quot;SHD&quot;, guide = guide_legend())+ theme_bw()+xlab(&quot;R&quot;)+ylab(&quot;structural hamming distance&quot;)+ theme(legend.position=&quot;bottom&quot;) parallel::stopCluster(cl) "],["references.html", "References", " References "]]
