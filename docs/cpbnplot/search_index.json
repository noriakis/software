[["index.html", "cpbnplot Chapter 1 cpbnplot: Bayesian network plot for enrichment analysis results 1.1 The preprocessing and DEG identification of GSE133624", " cpbnplot Noriaki Sato Chapter 1 cpbnplot: Bayesian network plot for enrichment analysis results The R package to plot Bayesian network inferred from expression data based on the enrichment analysis results including clusterProfiler or ReactomePA results (Wu et al. 2021; Yu and He 2016). It makes use of libraries including clusterProfiler, ReactomePA, bnlearn, graphite and depmap (Killian and Gatto 2021; Scutari 2010; Sales et al. 2012). The description of functions and several use cases are depicted in this book using GSE133624, which contains RNA-Seq data of bladder cancer and adjacent normal bladder tissues (Chen et al. 2019). 1.1 The preprocessing and DEG identification of GSE133624 In this book, the data from GSE133624 was used for the demonstrative purpose. DESeq2 is used to identify DEGs (Love, Huber, and Anders 2014). library(DESeq2) ## Load dataset and make metadata counts = read.table(&quot;GSE133624_reads-count-all-sample.txt&quot;, header=1, row.names=1) meta = sapply(colnames(counts), function (x) substring(x,1,1)) meta = data.frame(meta) colnames(meta) = c(&quot;Condition&quot;) dds &lt;- DESeqDataSetFromMatrix(countData = counts, colData = meta, design= ~ Condition) ## Prefiltering filt &lt;- rowSums(counts(dds) &lt; 10) &gt; dim(meta)[1]*0.9 dds &lt;- dds[!filt,] ## Perform DESeq2() dds = DESeq(dds) res = results(dds, pAdjustMethod = &quot;bonferroni&quot;) ## apply variance stabilizing transformation v = vst(dds, blind=T) vsted = assay(v) ## Plot PCA of VST values DESeq2::plotPCA(v, intgroup=&quot;Condition&quot;)+ theme_bw() ## Define the input genes, and use clusterProfiler::bitr to convert the ID. sig = subset(res, padj&lt;0.05) cand.entrez = clusterProfiler::bitr(rownames(sig), fromType=&quot;ENSEMBL&quot;, toType=&quot;ENTREZID&quot;, OrgDb=org.Hs.eg.db)$ENTREZID ## Perform enrichment analysis (ORA) pway = ReactomePA::enrichPathway(gene = cand.entrez) pwayGO = clusterProfiler::enrichGO(cand.entrez, ont = &quot;BP&quot;, OrgDb = org.Hs.eg.db) ## Convert to SYMBOL pway = setReadable(pway, OrgDb=org.Hs.eg.db) pwayGO = setReadable(pwayGO, OrgDb=org.Hs.eg.db) ## Store the similarity pway = enrichplot::pairwise_termsim(pway) ## Define including samples incSample = rownames(subset(meta, Condition==&quot;T&quot;)) Additionally, for the gene set enrichment analysis, log2 fold change is obtained. allEntrez = clusterProfiler::bitr(rownames(res), fromType=&quot;ENSEMBL&quot;, toType=&quot;ENTREZID&quot;, OrgDb=org.Hs.eg.db) res$ENSEMBL &lt;- rownames(res) lfc &lt;- merge(data.frame(res), allEntrez, by=&quot;ENSEMBL&quot;) lfc &lt;- lfc[order(lfc$log2FoldChange, decreasing=TRUE),] geneList &lt;- lfc$log2FoldChange names(geneList) &lt;- lfc$ENTREZID pwayGSE &lt;- ReactomePA::gsePathway(geneList) References "],["bootstrap-based-inference.html", "Chapter 2 bootstrap-based inference 2.1 bootstrap-based inference 2.2 Multiscale boostrap-based inference", " Chapter 2 bootstrap-based inference For bayesian network inference, two methods can be used. 2.1 bootstrap-based inference Original boot.strength() function from bnlearn follows parameterization of Imoto et al. (2002). Specify strType=\"normal\" which is default. Estimate the gene network \\(T\\) times from randomly sampled \\(X^*_{n} = (x^*_{1},...,x^*_{n})^T\\). Edge intensity is defined as \\((t1+t2)/T\\), and if \\(t1&gt;t2\\), edge confidence is defined as the confidence of direction of gene \\(i\\) to gene \\(j\\) is \\(t1/(t1+t2)\\), where the \\(t1\\) corresponds to the number of edges of gene \\(i\\) to \\(j\\) and \\(t2\\) the number of edges of gene \\(j\\) to \\(i\\). 2.2 Multiscale boostrap-based inference Additionally, the multiscale boostrap-based inference is implemented (Kamimura et al. 2003). Specify strType=\"ms\" for the multiscale version. The drawback is that it consumes more time. \\(n&#39;/n\\) was defined as the same parameter as the original paper. \\[n&#39;/n = (0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4)\\] For the arrays with altered numbers of multiple \\(\\tau=\\sqrt{n/n&#39;}\\), the bootstrap-based inference are performed. \\(MS_{ij}\\) is defined as \\(1-\\Phi(d_{ij}-c_{ij})\\), using the geometric quantities \\(d_{ij}\\) and \\(c_{ij}\\). Fitting \\(BP_{ij}(\\tau) = 1-\\Phi(d_{ij}/\\tau+c_{ij}\\tau)\\), we can determine the \\(MS_{ij}\\). The fitting was performed by msfit() available in pvclust. The confidence of direction was obtained by the same method as obtaining \\(MS_{ij}\\). The resulting edges were filtered by the threshold determined by the function inclusion.threshold from bnlearn. For both approaches, the superposed network possibly does not hold the cyclic assumption (Imoto et al. 2002). Additionally, if it is preferred, setting chooseDir = TRUE can select the direction of the undirected edges using the specified score by choose.direction function in bnlearn. References "],["bngeneplot.html", "Chapter 3 bngeneplot 3.1 barplot 3.2 The vanilla plot 3.3 The plot with the reference 3.4 The plot with the DepMap information 3.5 Plotting edge strengths 3.6 Plotting genes in multiple pathways", " Chapter 3 bngeneplot # Show top-30 pathways sorted by p-value in descending order. pway@result$Description[1:30] FALSE [1] &quot;Cell Cycle Checkpoints&quot; FALSE [2] &quot;Amplification of signal from the kinetochores&quot; FALSE [3] &quot;Amplification of signal from unattached kinetochores via a MAD2 inhibitory signal&quot; FALSE [4] &quot;Mitotic Prometaphase&quot; FALSE [5] &quot;Resolution of Sister Chromatid Cohesion&quot; FALSE [6] &quot;Mitotic Spindle Checkpoint&quot; FALSE [7] &quot;EML4 and NUDC in mitotic spindle formation&quot; FALSE [8] &quot;Activation of ATR in response to replication stress&quot; FALSE [9] &quot;Muscle contraction&quot; FALSE [10] &quot;DNA strand elongation&quot; FALSE [11] &quot;Mitotic Metaphase and Anaphase&quot; FALSE [12] &quot;Mitotic Anaphase&quot; FALSE [13] &quot;DNA Replication&quot; FALSE [14] &quot;RHO GTPases Activate Formins&quot; FALSE [15] &quot;Homologous DNA Pairing and Strand Exchange&quot; FALSE [16] &quot;S Phase&quot; FALSE [17] &quot;HDR through Homologous Recombination (HRR)&quot; FALSE [18] &quot;Separation of Sister Chromatids&quot; FALSE [19] &quot;Synthesis of DNA&quot; FALSE [20] &quot;Activation of the pre-replicative complex&quot; FALSE [21] &quot;Extracellular matrix organization&quot; FALSE [22] &quot;Presynaptic phase of homologous DNA pairing and strand exchange&quot; FALSE [23] &quot;Resolution of D-loop Structures through Holliday Junction Intermediates&quot; FALSE [24] &quot;Mitotic G1 phase and G1/S transition&quot; FALSE [25] &quot;M Phase&quot; FALSE [26] &quot;CDC6 association with the ORC:origin complex&quot; FALSE [27] &quot;Resolution of D-Loop Structures&quot; FALSE [28] &quot;DNA Double-Strand Break Repair&quot; FALSE [29] &quot;G1/S Transition&quot; FALSE [30] &quot;Resolution of D-loop Structures through Synthesis-Dependent Strand Annealing (SDSA)&quot; 3.1 barplot The default barplot() from clusterProfiler. barplot(pway, showCategory = 15) 3.2 The vanilla plot This function plots inferred relationship between genes in the specific pathway, with the boot-strapped strength between genes. The normal plot can be plotted by passing the results of clusterProfiler or ReactomePA, and (normalized) expression values as well as candidate samples to be included in the inference. For the pathway including many genes, parallel computing of bootstrap-based inference can be specified with cl parameter. Running bngeneplot in the default parameter. bngeneplot(results = pway, exp = vsted, pathNum = 17) Change the label for the better readability. bngeneplot(results = pway, exp = vsted, pathNum = 17, labelSize=7, shadowText=TRUE) In general, specify samples to be included. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 17) If the resulting network is messy, we can set threshold for the averaged network, which is automatically set by function threshold() from blnearn if not specified. convertSymbol converts the output to SYMBOL. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 17, R = 10, convertSymbol = TRUE, expRow = &quot;ENSEMBL&quot;, strThresh = 0.75) 3.2.1 Show the confidence of direction The value of the confidence of edge direction can be plotted by setting showDir = T. Note that the color represents the strength value. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 50, showDir = T, convertSymbol = T, expRow = &quot;ENSEMBL&quot;, strThresh = 0.7) 3.2.2 Show the hub genes Additionally, showing the hub gene (defined by hub parameter which highlights genes with top-\\(n\\) hub scores) is informative. Weighted Kleinberg’s hub centrality scores are calculated by igraph::hub_score(). bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 50, showDir = T, convertSymbol = T, expRow = &quot;ENSEMBL&quot;, hub=5, strThresh = 0.7) 3.3 The plot with the reference The relationship between genes can be compared with the reference network by the option compareRef=TRUE and specifying pathDb. By default, the intersection of two directed network is shown with the number of overlapping edges. library(parallel) cl = makeCluster(4) bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 13, R = 30, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, expRow = &quot;ENSEMBL&quot;, cl = cl) We can plot the difference between the reference network by specifying compareRefType=\"difference\". bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;difference&quot;, expRow = &quot;ENSEMBL&quot;) 3.4 The plot with the DepMap information Additionally, DepMap dependency scores can be plotted as the size of nodes using depmap package by specifying sizeDep=TRUE. It is especially useful for cancer-related research. You must provide depmap::depmap_crispr() or the other data describing the dependency score to dep variable. If not, CRISPR scores are downloaded, cached and used. Additionally, the name of cell line interested must be specified. If sizeDep=T, the histogram of overall and within-pathway dependency scores will be plotted besides the network. dep = depmap::depmap_crispr() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 5,compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep) It can be the RNA interference based score. rnai = depmap::depmap_rnai() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 3, R = 5,compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = rnai, cellLineName = &quot;UMUC3_URINARY_TRACT&quot;) Additionally, we can plot the dependency scores of interested genes across the lineage by specifying showLineage=TRUE. We must provide metadata from depmap::depmap_metadata() to depMeta. depMeta = depmap::depmap_metadata() bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep, showLineage = T, depMeta = depMeta) 3.5 Plotting edge strengths We can add a barplot depicting the edge strength and direction (probability), by specifying strengthPlot=TRUE and nStrength. bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = 15, R = 10, compareRef = T, convertSymbol = T, pathDb = &quot;reactome&quot;, compareRefType = &quot;intersection&quot;, expRow = &quot;ENSEMBL&quot;, sizeDep = T, dep = dep, strengthPlot = T, nStrength = 10) 3.6 Plotting genes in multiple pathways cl = makeCluster(8) bngeneplot(results = pway, exp = vsted, expSample = incSample, pathNum = c(15, 16), R = 10, convertSymbol = T, expRow = &quot;ENSEMBL&quot;) "],["bnpathplot.html", "Chapter 4 bnpathplot 4.1 emapplot 4.2 The vanilla plot 4.3 Compare with the reference 4.4 Reflect DepMap information to pathways 4.5 Aggregating the pathway databases", " Chapter 4 bnpathplot 4.1 emapplot The default emapplot from clusterProfiler. emapplot(pway) 4.2 The vanilla plot This function plots inferred relationship between pathways, with the boot-strapped strength between pathways. The normal plot can be plotted by bnpathplot, passing the results of clusterProfiler or ReactomePA, (normalized) expression values, and candidate rows to be included in the inference. nCategory specifies the number of categories (1:nCategory) to be plotted, sorted by the p-value. expRow indicates what identifiers are used in row names of expression matrix. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, labelSize=5, expRow = &quot;ENSEMBL&quot;) For the messy plot, the label can be modified using shadowText=TRUE. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, labelSize=3, shadowText=TRUE, expRow = &quot;ENSEMBL&quot;) It can be KEGG or GO pathway results using enrichKEGG and enrichGO. bnpathplot(results = pwayGO, exp = vsted, expSample = incSample, nCategory = 30, R = 10, expRow = &quot;ENSEMBL&quot;) Or it can be the GSEA result. bnpathplot(results = pwayGSE, exp = vsted, expSample = incSample, nCategory = 30, R = 10, expRow = &quot;ENSEMBL&quot;, shadowText = TRUE, color = &quot;enrichmentScore&quot;) 4.3 Compare with the reference For Reactome, the relationship between pathways can also be plotted by specifying compareRef=TRUE. Here, dotted lines indicate relationship not in the reference, and solid lines indicate those in the reference. bnpathplot(results = pway, exp = vsted, expSample = incSample, nCategory = 30, R = 10, compareRef=T, expRow = &quot;ENSEMBL&quot;) 4.4 Reflect DepMap information to pathways We can reflect overall dependency scores for the genes within the pathway by specifying sizeDep=TRUE. You must provide depmap::depmap_crispr or the other data describing the dependency score to dep variable. The average score of the genes in the pathway is used. bnpathplot(results = pwayGO, exp = vsted, expSample = incSample, nCategory = 30, R = 50, sizeDep = T, dep = dep, expRow = &quot;ENSEMBL&quot;) 4.5 Aggregating the pathway databases The multiple GSEA results can be aggregated, by just passing the multiple results like as follows. When choosing the number of categories (nCategory), the order of the results and the numbers should be same. library(DOSE) pwayDO &lt;- enrichDO(gene = cand.entrez) ReaAndDO &lt;- bnpathplot(results = c(pway, pwayDO), exp = vsted, expSample = incSample, nCategory = c(20, 20), R = 50) ReaAndDO "],["including-clinical-variables.html", "Chapter 5 Including clinical variables 5.1 Preparation of data 5.2 Inference of pathway relationship including clinical variables 5.3 Conditional probability query 5.4 Gene relationship with variables 5.5 Confirming the existing knowledge 5.6 Investigating the network based on the clinical question 5.7 Classification using BN", " Chapter 5 Including clinical variables 5.1 Preparation of data One of the important reasons of the Bayesian network analysis is assessing the relationship between gene expressions and clinical variables. cpbnplot offers incorporating metadata into inference. As a demonstrative purpose, the enrichment analysis results from GSE133624 is applied on data from The Cancer Genome Atlas Program (TCGA) (Cancer Genome Atlas Research Network et al. 2013). Specifically, TCGA-BLCA data is downloaded by the useful library TCGAbiolinks (Colaprico et al. 2016). library(TCGAbiolinks) ## Not run # query &lt;- GDCquery(project = &quot;TCGA-BLCA&quot;, # data.category = &quot;Transcriptome Profiling&quot;, # data.type = &quot;Gene Expression Quantification&quot;, # workflow.type = &quot;HTSeq - Counts&quot;) # download &lt;- GDCdownload(query) # tcgaData &lt;- GDCprepare(query) # save(file=&quot;tcgaData.rda&quot;, tcgaData) ## Load dataset load(file=&quot;tcgaData.rda&quot;) We again applied VST on the data, and filtered the metadata based on the variables to be included in the inference. In this analysis, age_at_diagnosis and paper_Combined T and LN category, which is a sum of Tumor category 1/2 (0) vs. 3/4 (1) and LN negative (0) vs positive (1), are included. library(DESeq2) library(dplyr) dataAssay &lt;- assays(tcgaData) tcgaCount &lt;- dataAssay@listData$`HTSeq - Counts` ## Make DESeq2 object ddsTCGA &lt;- DESeqDataSetFromMatrix(countData = tcgaCount, colData = tcgaData@colData, design= ~ 1) vstedTCGA &lt;- assay(vst(ddsTCGA)) ## Variable selection phase metadata &lt;- data.frame(tcgaData@colData) %&gt;% select(age_at_diagnosis, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) ## Scale and factorize metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) 5.2 Inference of pathway relationship including clinical variables We assess the relationship between the curated biological pathway information and clinical variables mentioned above. Variables other than expression data can be specified with otherVar, as well as otherVarName for their name. The order of otherVar must be same as column order of expression data. We use all the significant pathways of corrected p-values below 0.05. bnCov &lt;- bnpathplot(pway, vstedTCGA, nCategory = 1000, adjpCutOff = 0.05, expSample=rownames(metadata), algo=&quot;hc&quot;, strType=&quot;normal&quot;, otherVar=metadata, otherVarName=c(&quot;Age&quot;, &quot;Category&quot;), R=50, cl=parallel::makeCluster(10), returnNet=T) ## Check DAG igraph::is.dag(as.igraph(bnCov$av)) FALSE [1] TRUE ## Fit the parameter to network based on the data bnFit &lt;- bn.fit(bnCov$av, bnCov$df) Plot the resulting network. bnCov$plot 5.3 Conditional probability query Next we perform conditional probability queries by the bnlearn function cpdist to elucidate how the clinical variables affect pathway regulation. First we fit the inferred network to the original data. These are stored in the named list. Logic sampling is performed unless otherwise stated. Perform cpdist, and visualize the distribution of “Molecules associated with elastic fibres” conditional on the tumor category using ggdist. library(bnlearn) library(ggdist) library(ggplot2) candPath &lt;- &quot;Molecules associated with elastic fibres&quot; efz &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==0)) efo &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==1)) eft &lt;- cpdist(bnFit, nodes=c(candPath), evidence=(Category==2)) effect = data.frame( val = c(efz[,1], efo[,1], eft[,1]), stage = c(rep(&quot;0&quot;,nrow(efz)), rep(&quot;1&quot;, nrow(efo)), rep(&quot;2&quot;, nrow(eft))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(efz)), rep(stageWMean[2], nrow(efo)), rep(stageWMean[3], nrow(eft))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candPath) How the down-regulation in “Cell Cycle Checkpoints” affects the other pathways? This time using the importance sampling method, likelihood weighting. predNodes &lt;- names(bnFit) predNodes &lt;- predNodes[predNodes != &quot;Cell Cycle Checkpoints&quot;] maxVal &lt;- max(bnCov$df[candPath]) minVal &lt;- min(bnCov$df[candPath]) lowCCC &lt;- cpdist(bnFit, nodes=predNodes, evidence=list(&quot;Cell Cycle Checkpoints&quot;=minVal), method=&quot;lw&quot;) lowW &lt;- attributes(lowCCC)$weights highCCC &lt;- cpdist(bnFit, nodes=predNodes, evidence=list(&quot;Cell Cycle Checkpoints&quot;=maxVal), method=&quot;lw&quot;) highW &lt;- attributes(highCCC)$weights ## Remove the factor highCCC$Category &lt;- NULL lowCCC$Category &lt;- NULL difMeanCCC &lt;- apply(highCCC, 2, function(x) weighted.mean(x, highW)) - apply(lowCCC, 2, function(x) weighted.mean(x, lowW)) ## Top absolute value kable(head(difMeanCCC[order(abs(difMeanCCC), decreasing=TRUE)]), col.names=c(&quot;difference&quot;)) difference M Phase 26.42259 Mitotic Metaphase and Anaphase 23.35451 Mitotic Anaphase 23.19593 G2/M Transition 20.61755 Mitotic G2-G2/M phases 20.57334 Separation of Sister Chromatids 19.54699 ## Reflect the difference in the plot modifying ggplot2 object changeCol &lt;- bnCov$plot$data difMeanCCC &lt;- difMeanCCC[changeCol$name] names(difMeanCCC) &lt;- changeCol$name changeCol$color &lt;- difMeanCCC ## Replace the color, change the legend bnCov$plot$data &lt;- changeCol bnCov$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) 5.4 Gene relationship with variables For the genes in interesting pathway, clinical variables can be incorporated too. We investigated the genes involved in the reactome “Molecules associated with elastic fibres.” bnGeneCov &lt;- bngeneplot(pway, vstedTCGA, pathNum=43, expSample=rownames(metadata), otherVar=metadata, hub=5, R=100, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) Plot the resulting network of genes. ## Plot bnGeneCov$plot ## Check DAG igraph::is.dag(as.igraph(bnGeneCov$av)) FALSE [1] TRUE ## Fit the parameter to network based on the data bnFitGene &lt;- bn.fit(bnGeneCov$av, bnGeneCov$df) Perform cpdist, and examine the mean and distribution using ggdist. We can see that the expression of the gene EFEMP1, which is reported to be a candidate for a biomarker of aggressive bladder cancer or therapeutic targets (Han et al. 2017), is going up with each stage. candGene &lt;- &quot;EFEMP1&quot; efz &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==0)) efo &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==1)) eft &lt;- cpdist(bnFitGene, nodes=c(candGene), evidence=(Category==2)) effect = data.frame( val = c(efz[,1], efo[,1], eft[,1]), stage = c(rep(&quot;0&quot;,nrow(efz)), rep(&quot;1&quot;, nrow(efo)), rep(&quot;2&quot;, nrow(eft))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(efz)), rep(stageWMean[2], nrow(efo)), rep(stageWMean[3], nrow(eft))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) 5.5 Confirming the existing knowledge To confirm the validity of the inferred Bayesian network, we can focus on some genes that is already validated to be related to clinical information or is incorporated into the daily clinical practice. To obtain the pathways that include the specific gene, one can use obtainPath function. This time we focus on the gene MMP2, as the gene has been reported to be related to clinical variables in bladder cancer (Vasala, Pääkkö, and Turpeenniemi-Hujanen 2003; Fouad et al. 2019; Winerdal et al. 2018). pathSub &lt;- obtainPath(pway, &quot;MMP2&quot;) Using the top pathway involving MMP2, construct the network and plot. bnGeneCov2 &lt;- bngeneplot(pathSub, vstedTCGA, pathNum=1, expSample=rownames(metadata), otherVar=metadata, hub=5, R=50, algo=&quot;tabu&quot;, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnGeneCov2$plot bnGeneCov2$av &lt;- cpbnplot:::chooseEdgeDir(bnGeneCov2$av, bnGeneCov2$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) bnGeneCov2Fit &lt;- bn.fit(bnGeneCov2$av, bnGeneCov2$df) Predict the distribution. candGene &lt;- &quot;MMP2&quot; mz &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==0), method=&quot;ls&quot;) mo &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==1), method=&quot;ls&quot;) mt &lt;- cpdist(bnGeneCov2Fit, nodes=c(candGene), evidence=(Category==2), method=&quot;ls&quot;) effect = data.frame( val = c(mz[,1], mo[,1], mt[,1]), stage = c(rep(&quot;0&quot;,nrow(mz)), rep(&quot;1&quot;, nrow(mo)), rep(&quot;2&quot;, nrow(mt))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(mz)), rep(stageWMean[2], nrow(mo)), rep(stageWMean[3], nrow(mt))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) It is interesting to investigate whether the result is similar in the other database, like Gene Ontology doing the same analysis. ## Perform the same analysis on GO enrichment result pathSubGO &lt;- obtainPath(pwayGO, &quot;MMP2&quot;) bnCovGO &lt;- bngeneplot(pathSubGO, vstedTCGA, pathNum=1, expSample=rownames(metadata), otherVar=metadata, R=50, layout=&quot;sugiyama&quot;, otherVarName=c(&quot;Age&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnCovGO$av &lt;- cpbnplot:::chooseEdgeDir(bnCovGO$av, bnCovGO$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) bnGeneCovGOFit &lt;- bn.fit(bnCovGO$av, bnCovGO$df) mz &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==0), method=&quot;ls&quot;) mo &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==1), method=&quot;ls&quot;) mt &lt;- cpdist(bnGeneCovGOFit, nodes=c(candGene), evidence=(Category==2), method=&quot;ls&quot;) effect = data.frame( val = c(mz[,1], mo[,1], mt[,1]), stage = c(rep(&quot;0&quot;,nrow(mz)), rep(&quot;1&quot;, nrow(mo)), rep(&quot;2&quot;, nrow(mt))) ) disMean &lt;- effect %&gt;% group_by(stage) %&gt;% summarise(mean=mean(val)) stageWMean &lt;- paste0(disMean$stage, &quot; (mean=&quot;, round(disMean$mean,3), &quot;)&quot;) effect$stageLabel &lt;- c(rep(stageWMean[1],nrow(mz)), rep(stageWMean[2], nrow(mo)), rep(stageWMean[3], nrow(mt))) ggplot(effect, aes(x=val, y=stage, color=stageLabel, fill=stageLabel)) + scale_color_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + scale_fill_manual(values=c(&quot;steelblue&quot;,&quot;gold&quot;,&quot;tomato&quot;)) + stat_dotsinterval() + theme_bw() + ggtitle(candGene) + labs(caption=pathSubGO@result$Description[1]) 5.6 Investigating the network based on the clinical question After confirming the knowledge, it is interesting to test how difference in clinical variables affect gene expression. bnlearn can naturally handle this again using cpdist. We now include two more variables, age_at_diagnosis, gender, paper_Noninvasive.bladder.cancer.therapy, paper_Combined.T.and.LN.category. Inference based on these information, we can ask: Which genes have the biggest expression differences between those treated with BCG and with none, considering the networks of genes and clinical variables of age, gender, tumor category in TCGA-BLCA dataset using genes significantly differed in GSE133624 and involved in curated biological pathways related to MMP2? ## Metadata filtering metadata &lt;- data.frame(tcgaData@colData) %&gt;% select(age_at_diagnosis, gender, paper_Noninvasive.bladder.cancer.therapy, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) %&gt;% filter(paper_Noninvasive.bladder.cancer.therapy!=&quot;ND&quot;) metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$gender &lt;- as.factor(metadata$gender) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) metadata$paper_Noninvasive.bladder.cancer.therapy &lt;- as.factor(metadata$paper_Noninvasive.bladder.cancer.therapy) ## Subset to significant pathways, and those related to MMP2 pway@result &lt;- subset(pway@result, p.adjust&lt;0.05) pathSub &lt;- obtainPath(pway, &quot;MMP2&quot;) bnCovGene3 &lt;- bngeneplot(pathSub, vstedTCGA, pathNum = seq_len(nrow(pathSub)), expSample=rownames(metadata), otherVar=metadata, hub=5, R=50, otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;Therapy&quot;,&quot;Category&quot;), cl=parallel::makeCluster(10), returnNet=T) bnCovGene3$av &lt;- chooseEdgeDir(bnCovGene3$av, bnCovGene3$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) bnCovGene3Fit &lt;- bn.fit(bnCovGene3$av, bnCovGene3$df) allGenes &lt;- names(bnCovGene3$av$nodes) allGenes &lt;- allGenes[!allGenes %in% c(&quot;Age&quot;,&quot;Gender&quot;,&quot;Therapy&quot;,&quot;Category&quot;)] no &lt;- cpdist(bnCovGene3Fit, nodes=allGenes, evidence=(Therapy==&quot;none&quot;), method=&quot;ls&quot;) bcg &lt;- cpdist(bnCovGene3Fit, nodes=allGenes, evidence=(Therapy==&quot;Bacillus Calmette.Guerin (BCG)&quot;), method=&quot;ls&quot;) difMean &lt;- data.frame(apply(bcg, 2, mean)-apply(no, 2, mean)) difMean$name &lt;- rownames(difMean) colnames(difMean) &lt;- c(&quot;difference&quot;,&quot;name&quot;) difMean &lt;- difMean[order(abs(difMean$difference), decreasing=T),] kable(head(difMean, n=5)) difference name PCOLCE 0.3511844 PCOLCE ADAMTS8 -0.1952817 ADAMTS8 COL11A1 0.1914131 COL11A1 COL25A1 0.1877005 COL25A1 ELN -0.1367145 ELN We can reflect the difference to the plot. In the previous EFEMP1 plot: candGene &lt;- names(bnFitGene) candGene &lt;- candGene[candGene != &quot;Category&quot;] efz2 &lt;- cpdist(bnFitGene, nodes=candGene, evidence=(Category==0)) eft2 &lt;- cpdist(bnFitGene, nodes=candGene, evidence=(Category==2)) difMean &lt;- apply(eft2, 2, mean) - apply(efz2, 2, mean) changeCol &lt;- bnGeneCov$plot$data difMean &lt;- difMean[changeCol$name] names(difMean) &lt;- changeCol$name changeCol$color &lt;- difMean ## Replace shape and color changeCol$shape &lt;- rep(19, dim(bnGeneCov$plot$data)[1]) bnGeneCov$plot$data &lt;- changeCol bnGeneCov$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) 5.7 Classification using BN Inferred BN can be used as a classifier of conditions. In this analysis, we perform the classification of whether the cancer samples are harboring TP53 mutation or not (column paper_mutation in TP53). First, we make a metadata table as same as the above examples. metadata &lt;- data.frame(tcgaData@colData) %&gt;% dplyr::select(age_at_diagnosis, gender, paper_mutation.in.TP53, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_mutation.in.TP53!=&quot;ND&quot;) %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) table(metadata$paper_mutation.in.TP53) FALSE FALSE no yes FALSE 184 163 ## Set TP53 status to numeric of 0/1. metadata$paper_mutation.in.TP53 &lt;- as.numeric(as.factor(metadata$paper_mutation.in.TP53))-1 metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) metadata$gender &lt;- as.factor(metadata$gender) Split the data to train/test according to TP53 mutation status using caret (Kuhn 2008). In this analysis, the five-fold cross validation is performed. Fit the model using the expression of genes in the pathway. This time the classification performance of significant pathways (corrected p &lt; 1e-7) are to be compared. onlyDf option can be enabled to return only the data.frame containing data for prediction, useful for testing purpose. set.seed(53) # Seed for split trainIndex &lt;- caret::createFolds(factor(metadata$paper_mutation.in.TP53), k = 5, list = TRUE, returnTrain=TRUE) allnets &lt;- list() ## Store network in the list allClassRes &lt;- list() ## Store prediction in the list for (f in seq_len(5)) { nets &lt;- list() classRes &lt;- list() foldTrainIndex &lt;- trainIndex[[f]] ## Recursively fit and test for significant pathways for (pnum in seq(1, dim(subset(pway@result, p.adjust&lt;1e-5))[1], 1)) { cl &lt;- parallel::makeCluster(12) bnCovTrain &lt;- bngeneplot(pway, vstedTCGA[,rownames(metadata)][, foldTrainIndex], pathNum=pnum, layout=&quot;sugiyama&quot;, expSample=rownames(metadata[foldTrainIndex,]), algo=&quot;hc&quot;, strType=&quot;normal&quot;, otherVar=metadata[foldTrainIndex,], otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;TP53&quot;,&quot;Category&quot;), R=50, cl=cl, returnNet=T) ## Return only DF for testing bnCovTest &lt;- bngeneplot(pway, vstedTCGA[,rownames(metadata)][, -foldTrainIndex], pathNum=pnum, expSample=rownames(metadata[-foldTrainIndex,]), otherVar=metadata[-foldTrainIndex,], otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;TP53&quot;,&quot;Category&quot;), onlyDf=T) bnCovTrain$av &lt;- cpbnplot:::chooseEdgeDir(bnCovTrain$av, bnCovTrain$df, scoreType=&quot;mi-cg&quot;, debug=FALSE) ## If DAG and TP53 have parents if ( igraph::is.dag(bnlearn::as.igraph(bnCovTrain$av)) &amp;&amp; length(bnCovTrain$av$nodes$TP53$parents) &gt;= 1 ){ bnCovLargeFit &lt;- bnlearn::bn.fit(bnCovTrain$av, bnCovTrain$df) pred &lt;- sigmoid::sigmoid(predict(bnCovLargeFit, node=&quot;TP53&quot;, data=bnCovTest, method = &quot;bayes-lw&quot;)) # Use sigmoid function classRes[[pway@result$Description[pnum]]] &lt;- pred nets[[pway@result$Description[pnum]]] &lt;- bnCovTrain } else { message(paste0(&quot;Among pathway &quot;, pway@result$Description[pnum], &quot;, no parent node of TP53 is found, or inferred network is not dag.&quot;)) } parallel::stopCluster(cl) } allnets[[f]] &lt;- nets allClassRes[[f]] &lt;- classRes } Using the library pROC, calculate the area under ROC (auROC) (Robin et al. 2011). library(pROC) library(ggplotify) rocDf &lt;- c() allRocList &lt;- list() for (f in seq_len(5)) { correct &lt;- metadata[-trainIndex[[f]],]$paper_mutation.in.TP53 predDf &lt;- data.frame(allClassRes[[f]]) predDf$label &lt;- correct rocList &lt;- list() for (i in seq_len(dim(predDf)[2]-1)){ rocList[[names(predDf)[i]]] &lt;- roc(predDf$label, predDf[,i], ci=TRUE) } tmpRocDf &lt;- data.frame(t(data.frame(purrr::map(rocList, function(x) as.numeric(x$auc))))) colnames(tmpRocDf) &lt;- c(paste0(&quot;auc&quot;,f)) tmpRocDf$name &lt;- rownames(tmpRocDf) allRocList[[f]] &lt;- tmpRocDf } allRocListDf &lt;- allRocList %&gt;% purrr::reduce(left_join, by = &quot;name&quot;) rocMean &lt;- allRocListDf %&gt;% rowwise() %&gt;% mutate(Min = min(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Max = max(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Mean = mean(c_across(starts_with(&quot;auc&quot;)), na.rm=T), Sd = sd(c_across(starts_with(&quot;auc&quot;)), na.rm=T)) %&gt;% select(name ,Mean, Sd) %&gt;% arrange(desc(Mean)) kable(rocMean, row.names=FALSE, booktab=TRUE) %&gt;% kable_styling(font_size = 10) name Mean Sd Synthesis.of.DNA 0.7702640 0.0483161 S.Phase 0.7564041 0.0606541 DNA.strand.elongation 0.7558024 0.0515143 DNA.Replication 0.7418214 0.0724349 Mitotic.Spindle.Checkpoint 0.7385408 0.0384938 Mitotic.Anaphase 0.7359661 0.0436257 Resolution.of.Sister.Chromatid.Cohesion 0.7338589 0.0296269 Mitotic.Metaphase.and.Anaphase 0.7305106 0.0879798 Homologous.DNA.Pairing.and.Strand.Exchange 0.7290159 0.0428621 Activation.of.ATR.in.response.to.replication.stress 0.7269121 0.0367326 Amplification.of.signal.from.the.kinetochores 0.7195224 0.0399094 HDR.through.Homologous.Recombination..HRR. 0.7185543 0.0289043 RHO.GTPases.Activate.Formins 0.7082054 0.0360879 Cell.Cycle.Checkpoints 0.7065901 0.0451219 Mitotic.Prometaphase 0.7053514 0.0573109 Amplification..of.signal.from.unattached..kinetochores.via.a.MAD2..inhibitory.signal 0.6991004 0.0965263 Separation.of.Sister.Chromatids 0.6986134 0.0845527 EML4.and.NUDC.in.mitotic.spindle.formation 0.6749238 0.0708973 Show the resulting network with the top auROC, and the ROC plot using pROC (Robin et al. 2011). topPath &lt;- rocMean[1,&quot;name&quot;] candFold &lt;- as.numeric(allRocListDf %&gt;% filter(name == as.character(topPath)) %&gt;% summarize(which.max(c_across(starts_with(&quot;auc&quot;))))) ## With the CI candRoc &lt;- data.frame(metadata[-trainIndex[[candFold]],]$paper_mutation.in.TP53) colnames(candRoc) &lt;- c(&quot;label&quot;) candRoc$pred &lt;- as.numeric(unlist(allClassRes[[candFold]][gsub(&quot;[.]&quot;, &quot; &quot;, as.character(topPath))])) rocplot &lt;- as.ggplot(function(){ rocobj1 &lt;- plot.roc(candRoc$label, candRoc$pred, print.auc = TRUE, ci=TRUE, col=&quot;black&quot;, main = &quot;Mutation in TP53&quot;, percent=TRUE) ciobj &lt;- ci.se(rocobj1, specificities = seq(0, 100, 5)) plot(ciobj, type = &quot;shape&quot;, col = &quot;steelblue&quot;) }) ## Along with the network topNet &lt;- allnets[[candFold]][[gsub(&quot;[.]&quot;, &quot; &quot;, topPath)]] topNet$plot + rocplot Using bnlearn::cpdist, check the difference in the distribution mean when the value of the node TP53 is above and below 0.5. topFit &lt;- bnlearn::bn.fit(topNet$av, topNet$df) candNodes &lt;- names(topNet$av$nodes) candNodes &lt;- candNodes[!candNodes %in% c(&quot;TP53&quot;,&quot;Category&quot;,&quot;Gender&quot;)] tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &lt; 0.5)) dim(tp53low) FALSE [1] 5207 43 tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &gt; 0.5)) dim(tp53high) FALSE [1] 4753 43 difMeanTp53 &lt;- apply(tp53high, 2, mean) - apply(tp53low, 2, mean) kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM2 0.4732629 RFC4 0.4666554 ORC1 0.4331116 MCM8 0.4323734 GINS1 0.4120761 CCNE2 0.3795090 changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) When the TP53 takes the extreme values on logic sampling. topFit &lt;- bnlearn::bn.fit(topNet$av, topNet$df) candNodes &lt;- names(topNet$av$nodes) candNodes &lt;- candNodes[!candNodes %in% c(&quot;TP53&quot;,&quot;Category&quot;,&quot;Gender&quot;)] tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &lt; 0.01)) dim(tp53low) FALSE [1] 1814 43 tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=(TP53 &gt; 0.99)) dim(tp53high) FALSE [1] 1448 43 difMeanTp53 &lt;- apply(tp53high, 2, mean) - apply(tp53low, 2, mean) kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM2 0.9259180 RFC4 0.8718847 ORC1 0.8373246 GINS1 0.8137102 MCM8 0.8044904 PRIM1 0.7336477 changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) Perform likelihood weighting. tp53low &lt;- cpdist(topFit, nodes=candNodes, evidence=list(TP53 = 0), method=&quot;lw&quot;) tp53high &lt;- cpdist(topFit, nodes=candNodes, evidence=list(TP53 = 1), method=&quot;lw&quot;) difMeanTp53 &lt;- apply(tp53high, 2, function(x) weighted.mean(x, attributes(tp53high)$weights)) - apply(tp53low, 2, function(x) weighted.mean(x, attributes(tp53low)$weights)) changeCol &lt;- topNet$plot$data difMeanTp53 &lt;- difMeanTp53[changeCol$name] kable(head(difMeanTp53[order(abs(difMeanTp53), decreasing=T)]), col.names=c(&quot;difference&quot;)) difference MCM2 0.5981190 RFC4 0.5856990 ORC1 0.5484684 GINS1 0.5112619 MCM8 0.5072800 CCNA2 0.4784021 names(difMeanTp53) &lt;- changeCol$name changeCol$color &lt;- difMeanTp53 ## Replace shape and color topNet$plot$data &lt;- changeCol topNet$plot + scale_color_continuous(low=&quot;blue&quot;,high=&quot;red&quot;,name=&quot;difference&quot;) queryCpDistLw function performs sampling by likelihood weighting using cpdist, and returns the data.frame with weights. It just performs cpdist on the queried level and produce a plot. queryCpDistLs performs logic sampling. ## Only likelihood weighting is supported in queryCpDist. q1 &lt;- queryCpDistLw(topFit, names(difMeanTp53)[1], evidence=&quot;TP53&quot;, level=c(0,0.5,1)) kable(head(q1$df[,c(names(difMeanTp53)[1],&quot;weights&quot;)])) RFC2 weights 10.99188 0.8078536 10.16224 0.9962997 11.63254 0.1592045 10.83047 0.9999093 11.16883 0.9024512 10.14470 0.7950615 References "],["the-other-options.html", "Chapter 6 The other options 6.1 Bootstrap reasoning 6.2 Discretization 6.3 Custom visualization 6.4 Comparing multi scale and standard bootstrapping", " Chapter 6 The other options 6.1 Bootstrap reasoning For the bootstrapping approach, the averaged network sometimes does not hold directed acyclic assumptions, and the probabilistic reasoning cannot be performed. The bootReason function is implemented that performs probabilistic reasoning for each bootstrap replicate and return the mean of events, as well as difference in mean from the control level. metadata &lt;- data.frame(tcgaData@colData) %&gt;% dplyr::select(age_at_diagnosis, gender, paper_mutation.in.TP53, paper_Combined.T.and.LN.category) %&gt;% na.omit() %&gt;% filter(paper_mutation.in.TP53!=&quot;ND&quot;) %&gt;% filter(paper_Combined.T.and.LN.category!=&quot;ND&quot;) ## Set TP53 status to numeric of 0/1. metadata$paper_mutation.in.TP53 &lt;- as.numeric(as.factor(metadata$paper_mutation.in.TP53))-1 metadata$age_at_diagnosis &lt;- as.numeric(scale(metadata$age_at_diagnosis)) metadata$paper_Combined.T.and.LN.category &lt;- as.factor(metadata$paper_Combined.T.and.LN.category) metadata$gender &lt;- as.factor(metadata$gender) ## Return only the data frame df &lt;- bngeneplot(pway, vstedTCGA, pathNum=3, expSample=rownames(metadata), otherVar=metadata, otherVarName=c(&quot;Age&quot;,&quot;Gender&quot;,&quot;TP53&quot;,&quot;Category&quot;), onlyDf=T) ## Calculate for multiple levels tp53Res &lt;- bootReasonOne(df, 20, node=c(&quot;CENPH&quot;,&quot;NUP107&quot;), c(&quot;TP53&quot;), level=c(0, 0.25, 0.5, 0.75, 1), cont=0) FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.16 11.3 FALSE 2 0.25 9.25 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.40 11.2 FALSE 5 1 9.47 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.20 11.3 FALSE 2 0.25 9.27 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.37 11.2 FALSE 5 1 9.44 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.14 11.3 FALSE 2 0.25 9.23 11.3 FALSE 3 0.5 9.33 11.2 FALSE 4 0.75 9.41 11.2 FALSE 5 1 9.51 11.1 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.18 11.3 FALSE 2 0.25 9.24 11.3 FALSE 3 0.5 9.31 11.2 FALSE 4 0.75 9.39 11.2 FALSE 5 1 9.46 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.15 11.3 FALSE 2 0.25 9.24 11.3 FALSE 3 0.5 9.34 11.2 FALSE 4 0.75 9.40 11.2 FALSE 5 1 9.47 11.1 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.18 11.3 FALSE 2 0.25 9.26 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.39 11.2 FALSE 5 1 9.45 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.16 11.3 FALSE 2 0.25 9.23 11.3 FALSE 3 0.5 9.33 11.2 FALSE 4 0.75 9.41 11.2 FALSE 5 1 9.49 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.17 11.3 FALSE 2 0.25 9.25 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.39 11.2 FALSE 5 1 9.46 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.19 11.3 FALSE 2 0.25 9.25 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.39 11.2 FALSE 5 1 9.45 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.16 11.3 FALSE 2 0.25 9.24 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.39 11.2 FALSE 5 1 9.47 11.1 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.18 11.3 FALSE 2 0.25 9.24 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.38 11.2 FALSE 5 1 9.45 11.1 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.20 11.3 FALSE 2 0.25 9.26 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.39 11.2 FALSE 5 1 9.44 11.1 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.20 11.3 FALSE 2 0.25 9.26 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.38 11.2 FALSE 5 1 9.43 11.1 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.18 11.3 FALSE 2 0.25 9.25 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.40 11.2 FALSE 5 1 9.45 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.20 11.3 FALSE 2 0.25 9.26 11.2 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.38 11.2 FALSE 5 1 9.46 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.17 11.3 FALSE 2 0.25 9.25 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.40 11.2 FALSE 5 1 9.47 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.20 11.3 FALSE 2 0.25 9.26 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.38 11.2 FALSE 5 1 9.44 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.17 11.3 FALSE 2 0.25 9.25 11.3 FALSE 3 0.5 9.31 11.2 FALSE 4 0.75 9.39 11.2 FALSE 5 1 9.46 11.2 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.16 11.2 FALSE 2 0.25 9.25 11.2 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.40 11.3 FALSE 5 1 9.48 11.3 FALSE # A tibble: 5 × 3 FALSE level CENPH NUP107 FALSE &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 0 9.16 11.3 FALSE 2 0.25 9.25 11.3 FALSE 3 0.5 9.32 11.2 FALSE 4 0.75 9.40 11.2 FALSE 5 1 9.48 11.1 kable(tp53Res$difMean) Mean stdev level node 0.0725425 0.0115887 0.25 CENPH 0.1448624 0.0218349 0.50 CENPH 0.2162356 0.0294590 0.75 CENPH 0.2854647 0.0372784 1.00 CENPH -0.0356490 0.0192726 0.25 NUP107 -0.0630656 0.0345684 0.50 NUP107 -0.0985853 0.0524808 0.75 NUP107 -0.1296113 0.0703502 1.00 NUP107 6.2 Discretization If passed an option disc=TRUE, the continuous variables are discretized using arules::discretize function (Hahsler et al. 2011). The discretization of the gene expression data is discussed in Gallo et al. (2016). If the same discretization is to be applied on the other data like the training and test dataset, you can pass the training samples to tr option, and if some variables are not intended to be discretized, you should pass the column name to remainCont. bngeneplot(results = pway, exp = vsted, pathNum = 1, disc=TRUE, layout=&quot;sugiyama&quot;) 6.3 Custom visualization 6.3.1 The glowing nodes and edges In addition to the normal plot, custom function of visualization is implemented (bngeneplotCustom and bnpathplotCustom). For example, to effectively visualize the hub genes and edges with high strength by glowing the respective nodes and edges, below is an example using an idea of ggCyberPunk. Additionally, the edge and node colors are fully customizable. cl = parallel::makeCluster(6) bngeneplotCustom(results = pway, exp = vsted, expSample = incSample, R=50, cl=cl, layout=&quot;kk&quot;, fontFamily=&quot;sans&quot;, pathNum = c(11), strType=&quot;normal&quot;, sizeDep=T, dep=dep, showDir=T, hub=5, glowEdgeNum=5, strThresh=0.6, strengthPlot = T) For the demonstrative purpose, using the palettes and fonts of vapoRwave and showtext, the other visualizations are possible. Note that in custom visualization, only the network plot and strength barplot are supported. ## Use alien encounter fonts (http://www.hipsthetic.com/alien-encounters-free-80s-font-family/) sysfonts::font_add(family=&quot;alien&quot;,regular=&quot;SFAlienEncounters.ttf&quot;) showtext::showtext_auto() cl = parallel::makeCluster(6) bngeneplotCustom(results = pway, exp = vsted, expSample = incSample, R=20, cl=cl, fontFamily=&quot;alien&quot;, labelSize=4, pathNum = c(15), strType=&quot;normal&quot;, showDir=F, hub=5, glowEdgeNum=5, strThresh=0.6, strengthPlot = T, sizeDep=F, dep=dep, layout=&quot;kk&quot;, edgePal=c(&quot;#9239F6&quot;,&quot;#FF4373&quot;), nodePal=c(&quot;#F8B660&quot;,&quot;#FF0076&quot;), barLegendKeyCol=&quot;#0F0D1A&quot;, textCol=&quot;#EE9537&quot;, titleCol=&quot;#EE9537&quot;, backCol=&quot;#0F0D1A&quot;, barAxisCol=&quot;#EE9537&quot;, barTextCol=&quot;#EE9537&quot;, barPal=c(&quot;#9239F6&quot;, &quot;#FF4373&quot;), barPanelGridCol=&quot;#FFB967&quot;, barBackCol=&quot;#0F0D1A&quot;, titleSize=14 ) 6.4 Comparing multi scale and standard bootstrapping cl &lt;- parallel::makeCluster(6) comparePlot &lt;- bngeneplot(results = pway, exp = vsted, cl=cl, strType=&quot;normal&quot;, pathNum = 15, R = 50, returnNet=T, shadowText = TRUE) comparePlotMS &lt;- bngeneplot(results = pway, exp = vsted, cl=cl, strType=&quot;ms&quot;, pathNum = 15, R = 50, returnNet=T, shadowText = TRUE) kable(comparePlot$str %&gt;% filter(direction&gt;0.5) %&gt;% arrange(desc(strength)) %&gt;% head()) from to strength direction TOPBP1 ATR 0.9814815 0.8125000 RFC5 XRCC3 0.9629630 0.6458333 RAD51AP1 BRCA1 0.9629630 0.5879630 RFC2 ATR 0.9444444 0.5462963 CHEK1 RAD51 0.9074074 0.7949735 RAD51AP1 CHEK1 0.8518519 0.7739749 kable(comparePlotMS$str %&gt;% filter(direction&gt;0.5) %&gt;% arrange(desc(strength)) %&gt;% head()) from to strength direction RFC5 XRCC3 0.9988307 0.5143560 RFC2 ATR 0.9981892 0.8251665 BRIP1 BRCA2 0.9951984 0.6876182 DNA2 BLM 0.9933508 0.6871648 TOPBP1 ATR 0.9929435 0.8779386 RFC3 ATR 0.9874010 0.8598716 References "],["testing-the-score-inside-the-pathway.html", "Chapter 7 Testing the score inside the pathway", " Chapter 7 Testing the score inside the pathway Test whether the dependency scores of genes within the pathway is different from overall score distribution (depKStest). The type variable can be either cell_line or lineage. pway &lt;- depKStest(results = pway, type = &quot;cell_line&quot;, cellLineName = &quot;253J_URINARY_TRACT&quot;, adjMethod = &quot;bonferroni&quot;, dep = dep, depMeta = depMeta) ggplot(pway@result, aes(x=depAdjP)) + geom_histogram(aes(fill=..count..), col=&quot;black&quot;) + scale_fill_gradient(&quot;Count&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + theme_minimal(base_family = &quot;Arial Narrow&quot;) + ggtitle(&quot;253J_URINARY_TRACT&quot;)+ xlab(&quot;Adjusted p-value&quot;)+ theme(plot.title = element_text(hjust=0.5, face=&quot;bold&quot;), axis.text = element_text(size=10), axis.title = element_text(size=12)) Reflect information in the plot. bnpathplot(results = pway, exp = vsted, expSample = incSample, color = &quot;depAdjP&quot;, nCategory = 30, R = 10, labelSize=5, expRow = &quot;ENSEMBL&quot;) "],["testing-r.html", "Chapter 8 Testing R", " Chapter 8 Testing R We provide the diagnostic function of inferred network across multiple bootstrap numbers. We can test how R values affect the resulting network. It is very time consuming to test many genes, thus the setting up cl argument using library parallel is suggested. We can specify which scoring function to use by scoreType. Additionaly, returned strength data frame as well as raw data frame can be used to assess various metrics and thresholds like structural hamming distance. cl &lt;- parallel::makeCluster(6) pathTest &lt;- bnpathtest(results = pway, algo=&quot;tabu&quot;, exp = vsted, Rrange = seq(10, 300, 10), nCategory = 15, expSample = incSample, expRow = &quot;ENSEMBL&quot;, cl = cl) FALSE * testing Amplification of signal from the kinetochores - Resolution of Sister Chromatid Cohesion for direction. FALSE &gt; initial score for node Resolution of Sister Chromatid Cohesion is 31.12572 . FALSE &gt; score delta for arc Amplification of signal from the kinetochores -&gt; Resolution of Sister Chromatid Cohesion is -1.124389 . FALSE &gt; initial score for node Amplification of signal from the kinetochores is 15.01784 . FALSE &gt; score delta for arc Resolution of Sister Chromatid Cohesion -&gt; Amplification of signal from the kinetochores is 2.416496 . FALSE @ arc Resolution of Sister Chromatid Cohesion -&gt; Amplification of signal from the kinetochores is better . FALSE * testing Resolution of Sister Chromatid Cohesion - Amplification of signal from the kinetochores for direction. FALSE &gt; initial score for node Amplification of signal from the kinetochores is 15.01784 . FALSE &gt; score delta for arc Resolution of Sister Chromatid Cohesion -&gt; Amplification of signal from the kinetochores is 2.416496 . FALSE &gt; initial score for node Resolution of Sister Chromatid Cohesion is 31.12572 . FALSE &gt; score delta for arc Amplification of signal from the kinetochores -&gt; Resolution of Sister Chromatid Cohesion is -1.124389 . FALSE @ arc Resolution of Sister Chromatid Cohesion -&gt; Amplification of signal from the kinetochores is better . FALSE * testing Mitotic Spindle Checkpoint - Activation of ATR in response to replication stress for direction. FALSE &gt; initial score for node Activation of ATR in response to replication stress is -24.83411 . FALSE &gt; score delta for arc Mitotic Spindle Checkpoint -&gt; Activation of ATR in response to replication stress is 7.826909 . FALSE &gt; initial score for node Mitotic Spindle Checkpoint is -6.254592 . FALSE &gt; score delta for arc Activation of ATR in response to replication stress -&gt; Mitotic Spindle Checkpoint is 3.749413 . FALSE @ arc Mitotic Spindle Checkpoint -&gt; Activation of ATR in response to replication stress is better . FALSE * testing Activation of ATR in response to replication stress - Mitotic Spindle Checkpoint for direction. FALSE &gt; initial score for node Mitotic Spindle Checkpoint is -6.254592 . FALSE &gt; score delta for arc Activation of ATR in response to replication stress -&gt; Mitotic Spindle Checkpoint is 3.749413 . FALSE &gt; initial score for node Activation of ATR in response to replication stress is -24.83411 . FALSE &gt; score delta for arc Mitotic Spindle Checkpoint -&gt; Activation of ATR in response to replication stress is 7.826909 . FALSE @ arc Mitotic Spindle Checkpoint -&gt; Activation of ATR in response to replication stress is better . FALSE * testing Activation of ATR in response to replication stress - DNA strand elongation for direction. FALSE &gt; initial score for node DNA strand elongation is -38.64107 . FALSE &gt; score delta for arc Activation of ATR in response to replication stress -&gt; DNA strand elongation is 6.42342 . FALSE &gt; initial score for node Activation of ATR in response to replication stress is -19.16713 . FALSE &gt; score delta for arc DNA strand elongation -&gt; Activation of ATR in response to replication stress is 2.397173 . FALSE @ arc Activation of ATR in response to replication stress -&gt; DNA strand elongation is better . FALSE * testing DNA strand elongation - Activation of ATR in response to replication stress for direction. FALSE &gt; initial score for node Activation of ATR in response to replication stress is -19.16713 . FALSE &gt; score delta for arc DNA strand elongation -&gt; Activation of ATR in response to replication stress is 2.397173 . FALSE &gt; initial score for node DNA strand elongation is -38.64107 . FALSE &gt; score delta for arc Activation of ATR in response to replication stress -&gt; DNA strand elongation is 6.42342 . FALSE @ arc Activation of ATR in response to replication stress -&gt; DNA strand elongation is better . # Plot difEdges &lt;- sapply(pathTest$graph, function(x) sapply(pathTest$graph, function(y) length(E(difference(as.igraph(x), as.igraph(y)))))) difEdges &lt;- data.frame(difEdges[dim(difEdges)[1], colnames(difEdges)]) colnames(difEdges) &lt;- c(&quot;NumDif&quot;) ggplot(difEdges, aes(x=as.numeric(substring(rownames(difEdges), 2)), y=NumDif)) + geom_line(group=1)+ geom_point(aes(color=NumDif), size=5)+ scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, name=&quot;Number of different edges&quot;, guide = guide_legend())+ theme_bw()+xlab(&quot;R&quot;)+ylab(&quot;Number of different edges&quot;)+ theme(legend.position=&quot;bottom&quot;) pway@result[15,]$Count FALSE [1] 22 library(parallel) cl = makeCluster(6) geneTest &lt;- bngenetest(results = pway, algo=&quot;hc&quot;, pathNum=15, exp = vsted, Rrange=seq(10, 200, 10), expSample = incSample, expRow = &quot;ENSEMBL&quot;, cl = cl) FALSE * testing RFC5 - XRCC3 for direction. FALSE &gt; initial score for node XRCC3 is -36.77229 . FALSE &gt; score delta for arc RFC5 -&gt; XRCC3 is 12.79979 . FALSE &gt; initial score for node RFC5 is -20.48893 . FALSE &gt; score delta for arc XRCC3 -&gt; RFC5 is 3.938113 . FALSE @ arc RFC5 -&gt; XRCC3 is better . FALSE * testing XRCC3 - RFC5 for direction. FALSE &gt; initial score for node RFC5 is -20.48893 . FALSE &gt; score delta for arc XRCC3 -&gt; RFC5 is 3.938113 . FALSE &gt; initial score for node XRCC3 is -36.77229 . FALSE &gt; score delta for arc RFC5 -&gt; XRCC3 is 12.79979 . FALSE @ arc RFC5 -&gt; XRCC3 is better . FALSE * testing RFC2 - RAD51 for direction. FALSE &gt; initial score for node RAD51 is -22.57153 . FALSE &gt; score delta for arc RFC2 -&gt; RAD51 is 0.4129817 . FALSE &gt; initial score for node RFC2 is -9.60327 . FALSE &gt; score delta for arc RAD51 -&gt; RFC2 is 0.9636686 . FALSE @ arc RAD51 -&gt; RFC2 is better . FALSE * testing RAD51 - RFC2 for direction. FALSE &gt; initial score for node RFC2 is -9.60327 . FALSE &gt; score delta for arc RAD51 -&gt; RFC2 is 0.9636686 . FALSE &gt; initial score for node RAD51 is -22.57153 . FALSE &gt; score delta for arc RFC2 -&gt; RAD51 is 0.4129817 . FALSE @ arc RAD51 -&gt; RFC2 is better . difSHD &lt;- sapply(geneTest$graph, function(x) sapply(geneTest$graph, function(y) shd(x, y))) # Plot SHD compared to the highest R network difSHD &lt;- data.frame(difSHD[dim(difSHD)[1], colnames(difSHD)]) colnames(difSHD) &lt;- c(&quot;SHD&quot;) ggplot(difSHD, aes(x=as.numeric(substring(rownames(difSHD), 2)), y=SHD)) + geom_line(group=1)+ geom_point(aes(color=SHD), size=5)+ scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, name=&quot;SHD&quot;, guide = guide_legend())+ theme_bw()+xlab(&quot;R&quot;)+ylab(&quot;structural hamming distance&quot;)+ theme(legend.position=&quot;bottom&quot;) "],["references.html", "References", " References "]]
